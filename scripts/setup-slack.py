# scripts/setup-slack.py
# Interactive Slack workspace setup for the plan orchestrator.
# Creates a new Slack app (via manifest), private channels, and writes config.
#
# Usage:
#   python scripts/setup-slack.py --prefix myproject
#   python scripts/setup-slack.py --prefix myproject --app-name "My Orchestrator"
#   python scripts/setup-slack.py --prefix myproject --bot-token xoxb-... --app-token xapp-...
#   python scripts/setup-slack.py --prefix myproject --bot-token xoxb-... --app-token xapp-... --non-interactive
#   python scripts/setup-slack.py --prefix myproject --invite-user user@example.com

import argparse
import json
import os
import sys
import time
import urllib.parse
import urllib.request

# Channel suffixes that the orchestrator expects (must match plan-orchestrator.py)
CHANNEL_SUFFIXES = ("notifications", "defects", "features", "questions")

SLACK_API_BASE = "https://slack.com/api"
SLACK_APPS_URL = "https://api.slack.com/apps"

# Required bot token scopes for full orchestrator functionality
REQUIRED_BOT_SCOPES = [
    "chat:write",              # Send messages
    "channels:read",           # List public channels
    "channels:history",        # Read public channel history (polling)
    "channels:manage",         # Create public channels (fallback)
    "channels:join",           # Join public channels
    "groups:read",             # List private channels (discovery)
    "groups:history",          # Read private channel history (polling)
    "groups:write",            # Create private channels
    "groups:write.invites",    # Invite members to private channels
    "users:read",              # Look up user IDs (for --invite-user)
    "users:read.email",        # Look up user by email (for --invite-user)
]

CONFIG_PATH = ".claude/slack.local.yaml"
CONFIG_TEMPLATE = """# Slack configuration for plan orchestrator.
# Generated by scripts/setup-slack.py
# This file is gitignored and must never be committed.
slack:
  enabled: true
  bot_token: "{bot_token}"
  app_token: "{app_token}"
  channel_id: "{default_channel_id}"
  channel_prefix: "{prefix}"
  notify:
    on_plan_start: true
    on_task_complete: true
    on_plan_complete: true
    on_validation_fail: true
    on_budget_threshold: true
    on_question: true
    on_defect_found: true
    on_idea_found: true
  questions:
    enabled: true
    timeout_minutes: 60
    fallback: "skip"
"""


def slack_api(method: str, token: str, params: dict = None,
              post_json: dict = None) -> dict:
    """Call a Slack Web API method.

    Args:
        method: API method name (e.g. 'auth.test')
        token: Bearer token for authorization
        params: Query string parameters (for GET-style calls)
        post_json: JSON body for POST calls

    Returns:
        Parsed JSON response dict

    Raises:
        RuntimeError: If the API call fails or returns ok=false
    """
    url = f"{SLACK_API_BASE}/{method}"
    headers = {"Authorization": f"Bearer {token}"}

    if post_json is not None:
        headers["Content-Type"] = "application/json; charset=utf-8"
        data = json.dumps(post_json).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers=headers)
    elif params:
        url = f"{url}?{urllib.parse.urlencode(params)}"
        req = urllib.request.Request(url, headers=headers)
    else:
        req = urllib.request.Request(url, headers=headers)

    with urllib.request.urlopen(req, timeout=15) as resp:
        result = json.loads(resp.read())

    if not result.get("ok", False):
        error = result.get("error", "unknown")
        raise RuntimeError(f"Slack API {method} failed: {error}")

    return result


def slack_api_raw(method: str, token: str, params: dict = None,
                  post_json: dict = None) -> dict:
    """Call a Slack Web API method and return raw response (no ok check).

    Same as slack_api but does not raise on ok=false. Used when the caller
    needs to inspect the error code directly.
    """
    url = f"{SLACK_API_BASE}/{method}"
    headers = {"Authorization": f"Bearer {token}"}

    if post_json is not None:
        headers["Content-Type"] = "application/json; charset=utf-8"
        data = json.dumps(post_json).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers=headers)
    elif params:
        url = f"{url}?{urllib.parse.urlencode(params)}"
        req = urllib.request.Request(url, headers=headers)
    else:
        req = urllib.request.Request(url, headers=headers)

    with urllib.request.urlopen(req, timeout=15) as resp:
        return json.loads(resp.read())


def generate_app_manifest(app_name: str, prefix: str) -> dict:
    """Generate a Slack app manifest for the orchestrator.

    The manifest pre-configures all required scopes, socket mode,
    and interactivity so the user only needs to click through install.

    Args:
        app_name: Display name for the Slack app
        prefix: Channel prefix for description text

    Returns:
        Manifest dict ready for JSON serialization
    """
    return {
        "display_information": {
            "name": app_name,
            "description": (
                f"CI/CD pipeline orchestrator bot "
                f"(channels: {prefix}*)"
            ),
            "background_color": "#1a1a2e",
        },
        "features": {
            "bot_user": {
                "display_name": app_name,
                "always_online": True,
            },
        },
        "oauth_config": {
            "scopes": {
                "bot": REQUIRED_BOT_SCOPES,
            },
        },
        "settings": {
            "interactivity": {
                "is_enabled": True,
            },
            "org_deploy_enabled": False,
            "socket_mode_enabled": True,
            "token_rotation_enabled": False,
        },
    }


def verify_token(bot_token: str) -> str:
    """Verify a bot token is valid and return the bot user ID.

    Args:
        bot_token: The xoxb-... token to verify

    Returns:
        The bot's user ID (e.g. 'U0123456789')

    Raises:
        RuntimeError: If the token is invalid
    """
    result = slack_api("auth.test", bot_token)
    bot_user_id = result.get("user_id", "")
    team = result.get("team", "unknown workspace")
    print(f"  Bot authenticated as @{result.get('user', '?')} in {team}")
    return bot_user_id


def lookup_user_by_email(bot_token: str, email: str) -> str:
    """Look up a Slack user ID by email address.

    Args:
        bot_token: Bot token with users:read.email scope
        email: Email address to look up

    Returns:
        User ID string

    Raises:
        RuntimeError: If user not found or scope missing
    """
    result = slack_api("users.lookupByEmail", bot_token,
                       params={"email": email})
    user_id = result.get("user", {}).get("id", "")
    if not user_id:
        raise RuntimeError(f"Could not find Slack user for {email}")
    name = result.get("user", {}).get("real_name", email)
    print(f"  Found user: {name} ({user_id})")
    return user_id


def unarchive_channel(bot_token: str, channel_id: str) -> bool:
    """Attempt to unarchive a channel.

    Args:
        bot_token: Bot token with appropriate scope
        channel_id: Channel to unarchive

    Returns:
        True if unarchived, False if failed
    """
    result = slack_api_raw("conversations.unarchive", bot_token,
                           post_json={"channel": channel_id})
    return result.get("ok", False)


def create_channel(bot_token: str, channel_name: str,
                   is_private: bool = True) -> str:
    """Create a Slack channel, or return its ID if it exists.

    Creates private channels by default. Handles name_taken by looking up
    the existing channel, and handles archived channels by unarchiving them.

    Args:
        bot_token: Bot token with groups:write or channels:manage scope
        channel_name: Name for the new channel
        is_private: Create as private channel (default True)

    Returns:
        The channel ID
    """
    result = slack_api_raw("conversations.create", bot_token,
                           post_json={
                               "name": channel_name,
                               "is_private": is_private,
                           })

    if result.get("ok", False):
        channel_id = result["channel"]["id"]
        visibility = "private" if is_private else "public"
        print(f"  Created #{channel_name} ({channel_id}, {visibility})")
        return channel_id

    error = result.get("error", "unknown")

    if error == "name_taken":
        # Channel exists â€” find it (check both public and private)
        channel_id = find_channel_by_name(bot_token, channel_name)
        if channel_id:
            # Check if archived
            info = slack_api_raw("conversations.info", bot_token,
                                 params={"channel": channel_id})
            if (info.get("ok") and
                    info.get("channel", {}).get("is_archived", False)):
                print(f"  #{channel_name} is archived, unarchiving...")
                if unarchive_channel(bot_token, channel_id):
                    print(f"  Unarchived #{channel_name} ({channel_id})")
                else:
                    print(f"  WARNING: Could not unarchive #{channel_name}. "
                          f"Unarchive it manually in Slack, then re-run.")
                    sys.exit(1)
            else:
                print(f"  #{channel_name} already exists ({channel_id})")
            return channel_id

        raise RuntimeError(
            f"Channel #{channel_name} exists but could not find its ID. "
            f"It may be archived. Check Slack and unarchive or delete it, "
            f"then re-run this script."
        )

    if error == "missing_scope":
        scope_needed = "groups:write" if is_private else "channels:manage"
        raise RuntimeError(
            f"Missing scope '{scope_needed}' to create "
            f"{'private' if is_private else 'public'} channels. "
            f"Add it in Slack App > OAuth & Permissions, then reinstall."
        )

    raise RuntimeError(f"conversations.create failed: {error}")


def find_channel_by_name(bot_token: str, channel_name: str) -> str:
    """Find a channel ID by name, searching both public and private channels.

    Args:
        bot_token: Bot token with channels:read and groups:read scopes
        channel_name: Exact channel name to find

    Returns:
        Channel ID string, or empty string if not found
    """
    for channel_types in ("public_channel", "private_channel"):
        cursor = ""
        while True:
            params = {"types": channel_types, "limit": "200"}
            if cursor:
                params["cursor"] = cursor
            result = slack_api("conversations.list", bot_token, params=params)
            for ch in result.get("channels", []):
                if ch.get("name") == channel_name:
                    return ch["id"]
            cursor = (result.get("response_metadata", {})
                      .get("next_cursor", ""))
            if not cursor:
                break
    return ""


def join_channel(bot_token: str, channel_id: str) -> None:
    """Have the bot join a channel.

    For private channels, the bot is automatically a member after creation.
    This handles the case where the channel already existed.

    Args:
        bot_token: Bot token with channels:join scope
        channel_id: Channel to join
    """
    try:
        slack_api("conversations.join", bot_token,
                  post_json={"channel": channel_id})
    except RuntimeError as e:
        error_str = str(e)
        if ("already_in_channel" not in error_str
                and "method_not_supported_for_channel_type" not in error_str):
            raise


def invite_user_to_channel(bot_token: str, channel_id: str,
                           user_id: str) -> None:
    """Invite a user to a channel.

    Args:
        bot_token: Bot token with groups:write.invites scope
        channel_id: Channel to invite user to
        user_id: User ID to invite
    """
    try:
        slack_api("conversations.invite", bot_token,
                  post_json={"channel": channel_id, "users": user_id})
    except RuntimeError as e:
        error_str = str(e)
        if "already_in_channel" in error_str:
            pass  # Already a member, that's fine
        elif "cant_invite_self" in error_str:
            pass  # Bot trying to invite itself
        else:
            print(f"  WARNING: Could not invite user to channel: {e}")


def prompt_token(label: str, expected_prefix: str) -> str:
    """Prompt the user to paste a Slack token and validate its prefix.

    Args:
        label: Human-readable label (e.g. 'Bot Token')
        expected_prefix: Required prefix (e.g. 'xoxb-')

    Returns:
        The validated token string

    Raises:
        SystemExit: If running non-interactively (EOFError)
    """
    while True:
        try:
            value = input(
                f"  Paste your {label} ({expected_prefix}...): "
            ).strip()
        except EOFError:
            print(f"\n  ERROR: Cannot read {label} in non-interactive mode.")
            print(f"  Pass --bot-token and --app-token on the command line.")
            sys.exit(1)
        if value.startswith(expected_prefix):
            return value
        print(f"  Expected a token starting with '{expected_prefix}'. "
              f"Try again.")


def write_config(bot_token: str, app_token: str, default_channel_id: str,
                 prefix: str) -> str:
    """Write the slack.local.yaml config file.

    Args:
        bot_token: The xoxb-... bot token
        app_token: The xapp-... app-level token
        default_channel_id: Channel ID for the notifications channel
        prefix: Channel prefix string (with trailing dash)

    Returns:
        Path to the written config file
    """
    os.makedirs(os.path.dirname(CONFIG_PATH), exist_ok=True)

    content = CONFIG_TEMPLATE.format(
        bot_token=bot_token,
        app_token=app_token,
        default_channel_id=default_channel_id,
        prefix=prefix,
    )

    with open(CONFIG_PATH, "w") as f:
        f.write(content)

    return CONFIG_PATH


def main():
    parser = argparse.ArgumentParser(
        description="Set up Slack integration for the plan orchestrator"
    )
    parser.add_argument(
        "--prefix", required=True,
        help="Channel prefix (e.g. 'myproject'). "
             "Creates channels: {prefix}-notifications, {prefix}-defects, etc."
    )
    parser.add_argument(
        "--app-name", default="",
        help="Slack app display name (default: '{prefix} Orchestrator')"
    )
    parser.add_argument(
        "--bot-token", default="",
        help="Skip app creation; use an existing bot token (xoxb-...)"
    )
    parser.add_argument(
        "--app-token", default="",
        help="Existing app-level token (xapp-...), used with --bot-token"
    )
    parser.add_argument(
        "--invite-user", default="",
        help="Email address of a user to invite to all created channels"
    )
    parser.add_argument(
        "--public", action="store_true",
        help="Create public channels instead of private (default: private)"
    )
    parser.add_argument(
        "--non-interactive", action="store_true",
        help="Skip browser-open and input prompts. Requires --bot-token "
             "and --app-token."
    )
    args = parser.parse_args()

    # Validate non-interactive mode has required tokens
    if args.non_interactive and (not args.bot_token or not args.app_token):
        print("ERROR: --non-interactive requires both --bot-token and "
              "--app-token")
        sys.exit(1)

    # Validate token formats when provided via command line
    if args.bot_token and not args.bot_token.startswith("xoxb-"):
        print(f"ERROR: --bot-token must start with 'xoxb-' "
              f"(did you swap bot and app tokens?)")
        sys.exit(1)
    if args.app_token and not args.app_token.startswith("xapp-"):
        print(f"ERROR: --app-token must start with 'xapp-' "
              f"(did you swap bot and app tokens?)")
        sys.exit(1)

    is_private = not args.public
    prefix = args.prefix.rstrip("-") + "-"
    app_name = args.app_name or f"{args.prefix.title()} Orchestrator"
    channel_names = [f"{prefix}{suffix}" for suffix in CHANNEL_SUFFIXES]
    visibility = "private" if is_private else "public"

    print()
    print(f"Slack Setup for Plan Orchestrator")
    print(f"  App name:    {app_name}")
    print(f"  Prefix:      {prefix}")
    print(f"  Channels:    {', '.join(f'#{n}' for n in channel_names)}")
    print(f"  Visibility:  {visibility}")
    if args.invite_user:
        print(f"  Invite user: {args.invite_user}")
    print()

    # --- Step 1: Get tokens (create new app or use existing) ---

    bot_token = args.bot_token
    app_token = args.app_token
    step_count = 5 if args.invite_user else 4

    if bot_token:
        print(f"[1/{step_count}] Using existing tokens")
        if not app_token:
            app_token = prompt_token("App-Level Token", "xapp-")
    elif args.non_interactive:
        print("ERROR: --non-interactive requires --bot-token")
        sys.exit(1)
    else:
        print(f"[1/{step_count}] Create a new Slack App")
        manifest = generate_app_manifest(app_name, prefix)
        manifest_json = json.dumps(manifest, indent=2)

        print()
        print("  A Slack app manifest has been generated. Follow these steps:")
        print()
        print("  1. A browser will open to Slack's app creation page")
        print('  2. Click "Create New App" > "From a manifest"')
        print("  3. Select your workspace, then paste this manifest:")
        print()
        print("  --- MANIFEST (copy everything between the dashes) ---")
        print(manifest_json)
        print("  --- END MANIFEST ---")
        print()
        print("  4. Click 'Create' to finish app creation")
        print("  5. Go to 'Settings > Socket Mode' and generate an app token")
        print("     (any name, e.g. 'orchestrator')")
        print("  6. Go to 'OAuth & Permissions' and click 'Install to "
              "Workspace'")
        print("  7. Copy the Bot User OAuth Token and the App-Level Token")
        print()

        try:
            input("  Press Enter to open Slack in your browser...")
            import webbrowser
            webbrowser.open(SLACK_APPS_URL)
        except EOFError:
            print(f"\n  Open this URL manually: {SLACK_APPS_URL}")

        print()
        time.sleep(1)

        bot_token = prompt_token("Bot User OAuth Token", "xoxb-")
        app_token = prompt_token("App-Level Token", "xapp-")

    # --- Step 2: Verify token ---

    print()
    print(f"[2/{step_count}] Verifying bot token...")
    try:
        verify_token(bot_token)
    except Exception as e:
        print(f"  ERROR: Token verification failed: {e}")
        print("  Check that the token is correct and the app is installed.")
        sys.exit(1)

    # --- Step 3: Create channels ---

    print()
    print(f"[3/{step_count}] Creating {visibility} channels...")
    created_channels = {}
    for name in channel_names:
        try:
            channel_id = create_channel(bot_token, name,
                                        is_private=is_private)
            join_channel(bot_token, channel_id)
            created_channels[name] = channel_id
        except Exception as e:
            print(f"  ERROR creating #{name}: {e}")
            sys.exit(1)

    # The notifications channel is the default
    notifications_name = f"{prefix}notifications"
    default_channel_id = created_channels.get(notifications_name, "")
    if not default_channel_id:
        default_channel_id = next(iter(created_channels.values()), "")

    # --- Step 3b: Invite user if requested ---

    if args.invite_user:
        print()
        print(f"[4/{step_count}] Inviting {args.invite_user} to channels...")
        try:
            user_id = lookup_user_by_email(bot_token, args.invite_user)
            for name, channel_id in created_channels.items():
                invite_user_to_channel(bot_token, channel_id, user_id)
                print(f"  Invited to #{name}")
        except Exception as e:
            print(f"  WARNING: Could not invite user: {e}")
            print("  You can invite them manually in Slack.")

    # --- Step 4: Write config ---

    print()
    print(f"[{step_count}/{step_count}] Writing configuration...")
    config_path = write_config(bot_token, app_token, default_channel_id,
                               prefix)
    print(f"  Written to {config_path}")

    # --- Summary ---

    print()
    print("Setup complete! Channels created:")
    for name, cid in created_channels.items():
        role = name.replace(prefix, "")
        print(f"  #{name} ({cid}) -> {role}")
    print()
    print(f"Config: {config_path}")
    print()
    print("To start the pipeline with Slack integration:")
    print("  python scripts/auto-pipeline.py")
    print()


if __name__ == "__main__":
    main()
