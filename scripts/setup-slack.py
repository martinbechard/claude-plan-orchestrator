# scripts/setup-slack.py
# Interactive Slack workspace setup for the plan orchestrator.
# Creates a new Slack app (via manifest), channels, and writes config.
#
# Usage:
#   python scripts/setup-slack.py --prefix myproject
#   python scripts/setup-slack.py --prefix myproject --app-name "My Orchestrator"

import argparse
import json
import os
import sys
import time
import urllib.parse
import urllib.request
import webbrowser

# Channel suffixes that the orchestrator expects (must match plan-orchestrator.py)
CHANNEL_SUFFIXES = ("notifications", "defects", "features", "questions")

SLACK_API_BASE = "https://slack.com/api"
SLACK_APPS_URL = "https://api.slack.com/apps"

# Required bot token scopes for full orchestrator functionality
REQUIRED_BOT_SCOPES = [
    "chat:write",          # Send messages
    "channels:read",       # List channels
    "channels:history",    # Read message history (polling)
    "channels:manage",     # Create channels
    "channels:join",       # Join channels
    "groups:read",         # List private channels (discovery)
    "groups:history",      # Read private channel history
]

CONFIG_PATH = ".claude/slack.local.yaml"
CONFIG_TEMPLATE = """# Slack configuration for plan orchestrator.
# Generated by scripts/setup-slack.py
# This file is gitignored and must never be committed.
slack:
  enabled: true
  bot_token: "{bot_token}"
  app_token: "{app_token}"
  channel_id: "{default_channel_id}"
  channel_prefix: "{prefix}"
  notify:
    on_plan_start: true
    on_task_complete: true
    on_plan_complete: true
    on_validation_fail: true
    on_budget_threshold: true
    on_question: true
    on_defect_found: true
    on_idea_found: true
  questions:
    enabled: true
    timeout_minutes: 60
    fallback: "skip"
"""


def slack_api(method: str, token: str, params: dict = None,
              post_json: dict = None) -> dict:
    """Call a Slack Web API method.

    Args:
        method: API method name (e.g. 'auth.test')
        token: Bearer token for authorization
        params: Query string parameters (for GET-style calls)
        post_json: JSON body for POST calls

    Returns:
        Parsed JSON response dict

    Raises:
        RuntimeError: If the API call fails or returns ok=false
    """
    url = f"{SLACK_API_BASE}/{method}"
    headers = {"Authorization": f"Bearer {token}"}

    if post_json is not None:
        headers["Content-Type"] = "application/json; charset=utf-8"
        data = json.dumps(post_json).encode("utf-8")
        req = urllib.request.Request(url, data=data, headers=headers)
    elif params:
        url = f"{url}?{urllib.parse.urlencode(params)}"
        req = urllib.request.Request(url, headers=headers)
    else:
        req = urllib.request.Request(url, headers=headers)

    with urllib.request.urlopen(req, timeout=15) as resp:
        result = json.loads(resp.read())

    if not result.get("ok", False):
        error = result.get("error", "unknown")
        raise RuntimeError(f"Slack API {method} failed: {error}")

    return result


def generate_app_manifest(app_name: str, prefix: str) -> dict:
    """Generate a Slack app manifest for the orchestrator.

    The manifest pre-configures all required scopes, socket mode,
    and interactivity so the user only needs to click through install.

    Args:
        app_name: Display name for the Slack app
        prefix: Channel prefix for description text

    Returns:
        Manifest dict ready for JSON serialization
    """
    return {
        "display_information": {
            "name": app_name,
            "description": (
                f"CI/CD pipeline orchestrator bot "
                f"(channels: {prefix}*)"
            ),
            "background_color": "#1a1a2e",
        },
        "features": {
            "bot_user": {
                "display_name": app_name,
                "always_online": True,
            },
        },
        "oauth_config": {
            "scopes": {
                "bot": REQUIRED_BOT_SCOPES,
            },
        },
        "settings": {
            "interactivity": {
                "is_enabled": True,
            },
            "org_deploy_enabled": False,
            "socket_mode_enabled": True,
            "token_rotation_enabled": False,
        },
    }


def verify_token(bot_token: str) -> str:
    """Verify a bot token is valid and return the bot user ID.

    Args:
        bot_token: The xoxb-... token to verify

    Returns:
        The bot's user ID (e.g. 'U0123456789')

    Raises:
        RuntimeError: If the token is invalid
    """
    result = slack_api("auth.test", bot_token)
    bot_user_id = result.get("user_id", "")
    team = result.get("team", "unknown workspace")
    print(f"  Bot authenticated as @{result.get('user', '?')} in {team}")
    return bot_user_id


def create_channel(bot_token: str, channel_name: str) -> str:
    """Create a public Slack channel, or return its ID if it exists.

    Args:
        bot_token: Bot token with channels:manage scope
        channel_name: Name for the new channel

    Returns:
        The channel ID
    """
    try:
        result = slack_api("conversations.create", bot_token,
                           post_json={"name": channel_name})
        channel_id = result["channel"]["id"]
        print(f"  Created #{channel_name} ({channel_id})")
        return channel_id
    except RuntimeError as e:
        if "name_taken" in str(e):
            # Channel exists â€” find its ID
            channel_id = find_channel_by_name(bot_token, channel_name)
            if channel_id:
                print(f"  #{channel_name} already exists ({channel_id})")
                return channel_id
            raise RuntimeError(
                f"Channel #{channel_name} exists but could not find its ID. "
                f"Invite the bot to #{channel_name} manually."
            ) from e
        raise


def find_channel_by_name(bot_token: str, channel_name: str) -> str:
    """Find a channel ID by name using conversations.list.

    Args:
        bot_token: Bot token with channels:read scope
        channel_name: Exact channel name to find

    Returns:
        Channel ID string, or empty string if not found
    """
    cursor = ""
    while True:
        params = {"types": "public_channel", "limit": "200"}
        if cursor:
            params["cursor"] = cursor
        result = slack_api("conversations.list", bot_token, params=params)
        for ch in result.get("channels", []):
            if ch.get("name") == channel_name:
                return ch["id"]
        cursor = (result.get("response_metadata", {})
                  .get("next_cursor", ""))
        if not cursor:
            break
    return ""


def join_channel(bot_token: str, channel_id: str) -> None:
    """Have the bot join a channel.

    Args:
        bot_token: Bot token with channels:join scope
        channel_id: Channel to join
    """
    try:
        slack_api("conversations.join", bot_token,
                  post_json={"channel": channel_id})
    except RuntimeError as e:
        if "already_in_channel" not in str(e):
            raise


def prompt_token(label: str, expected_prefix: str) -> str:
    """Prompt the user to paste a Slack token and validate its prefix.

    Args:
        label: Human-readable label (e.g. 'Bot Token')
        expected_prefix: Required prefix (e.g. 'xoxb-')

    Returns:
        The validated token string
    """
    while True:
        value = input(f"  Paste your {label} ({expected_prefix}...): ").strip()
        if value.startswith(expected_prefix):
            return value
        print(f"  Expected a token starting with '{expected_prefix}'. Try again.")


def write_config(bot_token: str, app_token: str, default_channel_id: str,
                 prefix: str) -> str:
    """Write the slack.local.yaml config file.

    Args:
        bot_token: The xoxb-... bot token
        app_token: The xapp-... app-level token
        default_channel_id: Channel ID for the notifications channel
        prefix: Channel prefix string (with trailing dash)

    Returns:
        Path to the written config file
    """
    os.makedirs(os.path.dirname(CONFIG_PATH), exist_ok=True)

    content = CONFIG_TEMPLATE.format(
        bot_token=bot_token,
        app_token=app_token,
        default_channel_id=default_channel_id,
        prefix=prefix,
    )

    with open(CONFIG_PATH, "w") as f:
        f.write(content)

    return CONFIG_PATH


def main():
    parser = argparse.ArgumentParser(
        description="Set up Slack integration for the plan orchestrator"
    )
    parser.add_argument(
        "--prefix", required=True,
        help="Channel prefix (e.g. 'myproject'). "
             "Creates channels: {prefix}-notifications, {prefix}-defects, etc."
    )
    parser.add_argument(
        "--app-name", default="",
        help="Slack app display name (default: '{prefix} Orchestrator')"
    )
    parser.add_argument(
        "--bot-token", default="",
        help="Skip app creation; use an existing bot token (xoxb-...)"
    )
    parser.add_argument(
        "--app-token", default="",
        help="Existing app-level token (xapp-...), used with --bot-token"
    )
    args = parser.parse_args()

    prefix = args.prefix.rstrip("-") + "-"
    app_name = args.app_name or f"{args.prefix.title()} Orchestrator"
    channel_names = [f"{prefix}{suffix}" for suffix in CHANNEL_SUFFIXES]

    print()
    print(f"Slack Setup for Plan Orchestrator")
    print(f"  App name:    {app_name}")
    print(f"  Prefix:      {prefix}")
    print(f"  Channels:    {', '.join(f'#{n}' for n in channel_names)}")
    print()

    # --- Step 1: Get tokens (create new app or use existing) ---

    bot_token = args.bot_token
    app_token = args.app_token

    if bot_token:
        print("[1/4] Using existing tokens")
        if not app_token:
            app_token = prompt_token("App-Level Token", "xapp-")
    else:
        print("[1/4] Create a new Slack App")
        manifest = generate_app_manifest(app_name, prefix)
        manifest_json = json.dumps(manifest, indent=2)

        print()
        print("  A Slack app manifest has been generated. Follow these steps:")
        print()
        print("  1. A browser will open to Slack's app creation page")
        print('  2. Click "Create New App" > "From a manifest"')
        print("  3. Select your workspace, then paste this manifest:")
        print()
        print("  --- MANIFEST (copy everything between the dashes) ---")
        print(manifest_json)
        print("  --- END MANIFEST ---")
        print()
        print("  4. Click 'Create' to finish app creation")
        print("  5. Go to 'Settings > Socket Mode' and generate an app token")
        print("     (any name, e.g. 'orchestrator')")
        print("  6. Go to 'OAuth & Permissions' and click 'Install to Workspace'")
        print("  7. Copy the Bot User OAuth Token and the App-Level Token")
        print()

        input("  Press Enter to open Slack in your browser...")
        webbrowser.open(SLACK_APPS_URL)
        print()

        # Wait a moment for the browser to open
        time.sleep(1)

        bot_token = prompt_token("Bot User OAuth Token", "xoxb-")
        app_token = prompt_token("App-Level Token", "xapp-")

    # --- Step 2: Verify token ---

    print()
    print("[2/4] Verifying bot token...")
    try:
        verify_token(bot_token)
    except Exception as e:
        print(f"  ERROR: Token verification failed: {e}")
        print("  Check that the token is correct and the app is installed.")
        sys.exit(1)

    # --- Step 3: Create channels ---

    print()
    print("[3/4] Creating channels...")
    created_channels = {}
    for name in channel_names:
        try:
            channel_id = create_channel(bot_token, name)
            join_channel(bot_token, channel_id)
            created_channels[name] = channel_id
        except Exception as e:
            print(f"  ERROR creating #{name}: {e}")
            print("  You may need to add 'channels:manage' scope to the bot.")
            sys.exit(1)

    # The notifications channel is the default
    notifications_name = f"{prefix}notifications"
    default_channel_id = created_channels.get(notifications_name, "")
    if not default_channel_id:
        default_channel_id = next(iter(created_channels.values()), "")

    # --- Step 4: Write config ---

    print()
    print("[4/4] Writing configuration...")
    config_path = write_config(bot_token, app_token, default_channel_id, prefix)
    print(f"  Written to {config_path}")

    # --- Summary ---

    print()
    print("Setup complete! Channels created:")
    for name, cid in created_channels.items():
        role = name.replace(prefix, "")
        print(f"  #{name} ({cid}) -> {role}")
    print()
    print(f"Config: {config_path}")
    print()
    print("To start the pipeline with Slack integration:")
    print("  python scripts/auto-pipeline.py")
    print()


if __name__ == "__main__":
    main()
