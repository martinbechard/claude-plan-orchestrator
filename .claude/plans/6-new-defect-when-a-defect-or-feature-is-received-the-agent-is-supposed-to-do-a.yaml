meta:
  name: 'Defect Fix: Enforce Complete 5 Whys Analysis in Intake Pipeline'
  description: 'Add retry logic to _run_intake_analysis() in plan-orchestrator.py
    so that when the LLM returns fewer than 5 Whys, the system retries once with INTAKE_RETRY_PROMPT
    before proceeding. The constants and prompt templates already exist from a prior
    partial fix (Task 1.1). This plan completes the remaining work: wiring up the
    retry logic, adding unit tests, and verifying the fix.

    Prior verification found: constants REQUIRED_FIVE_WHYS_COUNT, MAX_INTAKE_RETRIES,
    and INTAKE_RETRY_PROMPT are defined but unused. _run_intake_analysis() does not
    validate five_whys count or retry.

    '
  plan_doc: docs/plans/2026-02-17-6-new-defect-when-a-defect-or-feature-is-received-the-agent-is-supposed-to-do-a-design.md
  created: '2026-02-17'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - issue-verifier
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Implementation
  status: completed
  tasks:
  - id: '1.1'
    name: Add 5 Whys validation and retry logic to _run_intake_analysis
    agent: coder
    status: completed
    description: "In scripts/plan-orchestrator.py, modify the _run_intake_analysis()\
      \ method to validate the 5 Whys count and retry if incomplete.\n\nContext: The\
      \ constants REQUIRED_FIVE_WHYS_COUNT=5, MAX_INTAKE_RETRIES=1, and INTAKE_RETRY_PROMPT\
      \ are already defined near line 140-216. The _parse_intake_response() static\
      \ method (line ~3695) already extracts a five_whys list. The _run_intake_analysis()\
      \ method (line ~3740) calls the LLM and parses the response but does NOT validate\
      \ the five_whys count.\n\nIn _run_intake_analysis(), find the section after\
      \ line 3786 where five_whys is extracted:\n\n    five_whys = parsed[\"five_whys\"\
      ]\n    classification = parsed[\"classification\"]\n\n    # Build description\n\
      \    description = parsed[\"description\"] or response_text\n\nInsert the following\
      \ validation+retry block BETWEEN the classification extraction and the description\
      \ build:\n\n    # Validate 5 Whys completeness and retry if needed\n    if len(five_whys)\
      \ < REQUIRED_FIVE_WHYS_COUNT:\n        print(f\"[INTAKE] Only {len(five_whys)}\
      \ Whys returned, retrying...\")\n        retry_prompt = INTAKE_RETRY_PROMPT.format(\n\
      \            count=len(five_whys),\n            item_type=intake.item_type,\n\
      \            text=intake.original_text,\n            analysis=response_text,\n\
      \        )\n        retry_text = self._call_claude_print(\n            retry_prompt,\
      \ model=\"sonnet\",\n            timeout=INTAKE_ANALYSIS_TIMEOUT_SECONDS\n \
      \       )\n        if retry_text:\n            retry_parsed = self._parse_intake_response(retry_text)\n\
      \            if len(retry_parsed[\"five_whys\"]) >= len(five_whys):\n      \
      \          # Retry produced equal or better results\n                parsed\
      \ = retry_parsed\n                response_text = retry_text\n             \
      \   title = parsed[\"title\"] or fallback_title\n                root_need =\
      \ parsed[\"root_need\"]\n                five_whys = parsed[\"five_whys\"]\n\
      \                classification = parsed[\"classification\"]\n             \
      \   intake.analysis = response_text\n\n    if len(five_whys) < REQUIRED_FIVE_WHYS_COUNT:\n\
      \        print(f\"[INTAKE] WARNING: Only {len(five_whys)}/{REQUIRED_FIVE_WHYS_COUNT}\
      \ Whys in final analysis\")\n\n    # Build description: use parsed description,\
      \ or the full LLM\n    # response as-is if no structured description was found\n\
      \    description = parsed[\"description\"] or response_text\n\nIMPORTANT: Remove\
      \ the existing 'description = parsed[\"description\"] or response_text' line\
      \ (currently ~line 3791) since the retry block now handles it. The description\
      \ assignment moves to after the retry block.\n\nAfter making changes, verify\
      \ syntax:\n  python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True)\"\n"
    attempts: 1
    last_attempt: '2026-02-17T11:46:50.547188'
    model_used: sonnet
    completed_at: '2026-02-17T11:49:04.346819'
    result_message: Added 5 Whys validation and retry logic to _run_intake_analysis
      method. Validates count after parsing, retries with INTAKE_RETRY_PROMPT if incomplete,
      and logs warning if final count is below 5.
- id: phase-2
  name: Phase 2 - Tests
  status: pending
  tasks:
  - id: '2.1'
    name: Add unit tests for 5 Whys retry behavior
    agent: coder
    depends_on:
    - '1.1'
    status: pending
    description: "Add tests to tests/test_plan_orchestrator.py for the 5 Whys retry\
      \ logic in _run_intake_analysis().\n\nFirst read the existing tests/test_plan_orchestrator.py\
      \ to understand the import pattern and test structure.\n\nThe tests need to\
      \ mock _call_claude_print and create_backlog_item on a SlackNotifier instance.\
      \ Use unittest.mock.patch.object or similar. The IntakeState dataclass is at\
      \ ~line 911 of plan-orchestrator.py.\n\nImport SlackNotifier and IntakeState\
      \ using the same pattern as existing tests in the file. Also import REQUIRED_FIVE_WHYS_COUNT\
      \ from the module.\n\nAdd these test functions:\n\n1. test_intake_no_retry_when_five_whys_complete:\n\
      \   Create a mock SlackNotifier with _call_claude_print returning a response\
      \ with 5 Whys.\n   Build a complete LLM response string with Title:, Classification:,\
      \ 5 Whys: (5 items), Root Need:, Description: sections.\n   Mock _call_claude_print\
      \ to return this string, mock create_backlog_item to return a dict.\n   Mock\
      \ send_status to do nothing.\n   Create an IntakeState and call _run_intake_analysis(intake).\n\
      \   Assert _call_claude_print was called exactly once (no retry).\n\n2. test_intake_retries_on_incomplete_whys:\n\
      \   Mock _call_claude_print with side_effect returning 2 Whys first, then 5\
      \ Whys on second call.\n   Call _run_intake_analysis.\n   Assert _call_claude_print\
      \ was called exactly twice.\n   Assert the backlog item was created (create_backlog_item\
      \ called).\n\n3. test_intake_proceeds_after_failed_retry:\n   Mock _call_claude_print\
      \ with side_effect returning 2 Whys both times.\n   Call _run_intake_analysis.\n\
      \   Assert _call_claude_print was called twice.\n   Assert create_backlog_item\
      \ was still called (graceful degradation).\n\n4. test_intake_retry_uses_better_result:\n\
      \   Mock _call_claude_print: first returns 2 Whys, retry returns 4 Whys.\n \
      \  Call _run_intake_analysis.\n   Assert _call_claude_print called twice.\n\
      \   Check the description passed to create_backlog_item contains 4 Why items\
      \ (the retry result was used since 4 >= 2).\n\nHelper: create a function that\
      \ builds a valid LLM response string with a given number of Whys:\n\n  def build_intake_response(num_whys=5,\
      \ title=\"Test Title\"):\n      whys = \"\\n\".join(f\"{i+1}. Why {i+1} goes\
      \ here\" for i in range(num_whys))\n      return f\"\"\"Title: {title}\\nClassification:\
      \ defect - test\\n5 Whys:\\n{whys}\\nRoot Need: Test root need\\nDescription:\\\
      nTest description.\"\"\"\n\nAfter writing tests, run them:\n  ~/.pyenv/versions/3.11.*/bin/python\
      \ -m pytest tests/test_plan_orchestrator.py -v\n\nFix any failures immediately.\n"
- id: phase-3
  name: Phase 3 - Verification
  status: pending
  tasks:
  - id: '3.1'
    name: Verify syntax and run full test suite
    agent: code-reviewer
    depends_on:
    - '2.1'
    status: pending
    description: "Run the following verification steps:\n\n1. Compile-check both main\
      \ scripts:\n   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run the full test suite:\n   python3 -m pytest tests/ 2>/dev/null ||\
      \ echo 'No test suite configured'\n\n3. Verify retry logic exists in _run_intake_analysis:\n\
      \   grep -n 'REQUIRED_FIVE_WHYS_COUNT' scripts/plan-orchestrator.py\n   Expected:\
      \ at least 3 matches (definition + 2 usages in _run_intake_analysis).\n\n4.\
      \ Verify INTAKE_RETRY_PROMPT is used:\n   grep -n 'INTAKE_RETRY_PROMPT' scripts/plan-orchestrator.py\n\
      \   Expected: at least 2 matches (definition + usage in _run_intake_analysis).\n\
      \n5. Verify retry tests exist:\n   grep -n 'def test_intake.*retry\\|def test_intake.*complete'\
      \ tests/test_plan_orchestrator.py\n   Expected: at least 3 test functions.\n\
      \n6. Verify the warning log for incomplete analysis:\n   grep -n 'WARNING.*Whys.*final\\\
      |Only.*Whys returned' scripts/plan-orchestrator.py\n   Expected: 2 matches (retry\
      \ trigger log + final warning).\n\nReport findings as PASS/WARN/FAIL.\n"
