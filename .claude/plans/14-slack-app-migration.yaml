meta:
  name: Slack App Migration
  description: 'Replace the Incoming Webhook transport in SlackNotifier with a Slack
    App using the Web API (chat.postMessage) for sending and Socket Mode (slack-bolt)
    for receiving interactive responses. Config changes from webhook_url to bot_token
    + app_token + channel_id. Sending remains stdlib-only. Socket Mode is optional
    - falls back to file-based polling if slack-bolt is not installed. The public
    API (send_status, send_defect, send_idea, send_question, process_agent_messages)
    and all lifecycle hooks are preserved unchanged.

    '
  plan_doc: docs/plans/2026-02-16-14-slack-app-migration-design.md
  created: '2026-02-16'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Config Template Update
  status: completed
  tasks:
  - id: '1.1'
    name: Update Slack config template for Slack App
    agent: coder
    status: completed
    description: "Update the Slack configuration template to use Slack App credentials\
      \ instead of webhook URL.\nReference: docs/plans/2026-02-16-14-slack-app-migration-design.md\n\
      \ Steps:\n1. Read .claude/slack.local.yaml.template (current content uses webhook_url).\n\
      \ 2. Replace the file contents with the new Slack App configuration:\n\n   \
      \ # Slack notifications for the plan orchestrator.\n    # Copy this file to\
      \ .claude/slack.local.yaml and fill in your tokens.\n    # The .local.yaml file\
      \ is gitignored and must never be committed.\n    #\n    # Setup: Create a Slack\
      \ App at https://api.slack.com/apps\n    #   1. Create new app from scratch\n\
      \    #   2. Enable Socket Mode (Settings > Socket Mode) - generates app_token\
      \ (xapp-...)\n    #   3. Add Bot Token Scopes (OAuth & Permissions): chat:write,\
      \ channels:read\n    #   4. Enable Interactivity (Interactivity & Shortcuts)\
      \ - required for button responses\n    #   5. Install to workspace - generates\
      \ bot_token (xoxb-...)\n    #   6. Invite bot to your channel, note the channel_id\
      \ (right-click channel > View channel details)\n    #   7. For interactive questions:\
      \ pip install slack-bolt (optional, falls back to file polling)\n    slack:\n\
      \      enabled: true\n      bot_token: \"xoxb-your-bot-token-here\"\n      app_token:\
      \ \"xapp-your-app-token-here\"\n      channel_id: \"C0123456789\"\n      notify:\n\
      \        on_plan_start: true\n        on_task_complete: true\n        on_plan_complete:\
      \ true\n        on_validation_fail: true\n        on_budget_threshold: true\n\
      \        on_question: true\n        on_defect_found: true\n        on_idea_found:\
      \ true\n      questions:\n        enabled: true\n        timeout_minutes: 60\n\
      \        fallback: \"skip\"\n\n 3. Verify the template is valid YAML:\n    python3\
      \ -c \"\n    import yaml\n    with open('.claude/slack.local.yaml.template')\
      \ as f:\n        config = yaml.safe_load(f)\n    assert config['slack']['enabled']\
      \ is True\n    assert 'bot_token' in config['slack']\n    assert 'app_token'\
      \ in config['slack']\n    assert 'channel_id' in config['slack']\n    assert\
      \ 'webhook_url' not in config['slack']\n    print('Template validated OK')\n\
      \    \"\n\n Files: .claude/slack.local.yaml.template\n"
    attempts: 1
    last_attempt: '2026-02-16T19:49:44.215702'
    model_used: sonnet
    completed_at: '2026-02-16T19:51:36.108560'
    result_message: 'Updated Slack config template: replaced webhook_url with bot_token/app_token/channel_id
      fields, added comprehensive Slack App setup instructions'
- id: phase-2
  name: Phase 2 - SlackNotifier Transport Migration
  status: completed
  tasks:
  - id: '2.1'
    name: Replace webhook transport with Web API in SlackNotifier
    agent: coder
    status: completed
    depends_on:
    - '1.1'
    description: "Update SlackNotifier in scripts/plan-orchestrator.py to use chat.postMessage\
      \ instead of webhooks.\n Reference: docs/plans/2026-02-16-14-slack-app-migration-design.md\n\
      \ Steps:\n 1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class\
      \ (around line 2527).\n\n 2. In __init__, replace the config loading:\n    -\
      \ Remove: self._webhook_url = slack_config.get(\"webhook_url\", \"\")\n    -\
      \ Add: self._bot_token = slack_config.get(\"bot_token\", \"\")\n    - Add: self._app_token\
      \ = slack_config.get(\"app_token\", \"\")\n    - Add: self._channel_id = slack_config.get(\"\
      channel_id\", \"\")\n\n 3. Replace the _post_webhook method with _post_message:\n\
      \    def _post_message(self, payload: dict) -> bool:\n        \"\"\"POST a message\
      \ to Slack via chat.postMessage API.\n        Uses urllib.request with Bearer\
      \ token auth. Returns True on success.\n        Catches all exceptions and logs\
      \ errors without raising.\"\"\"\n        if not self._bot_token or not self._channel_id:\n\
      \            return False\n        payload[\"channel\"] = self._channel_id\n\
      \        try:\n            req = urllib.request.Request(\n                \"\
      https://slack.com/api/chat.postMessage\",\n                data=json.dumps(payload).encode(\"\
      utf-8\"),\n                headers={\n                    \"Content-Type\":\
      \ \"application/json; charset=utf-8\",\n                    \"Authorization\"\
      : f\"Bearer {self._bot_token}\"\n                }\n            )\n        \
      \    with urllib.request.urlopen(req, timeout=10) as resp:\n               \
      \ result = json.loads(resp.read())\n                return result.get(\"ok\"\
      , False)\n        except Exception as e:\n            print(f\"[SLACK] Failed\
      \ to post message: {e}\")\n            return False\n\n 4. Update send_status:\
      \ replace self._post_webhook with self._post_message.\n    Also update the guard:\
      \ change 'not self._webhook_url' to\n    'not self._bot_token or not self._channel_id'.\n\
      \n 5. Update send_defect: replace self._post_webhook with self._post_message.\n\
      \n 6. Update send_idea: replace self._post_webhook with self._post_message.\n\
      \n 7. Update the class docstring to say 'Slack Web API' instead of 'Incoming\
      \ Webhooks',\n    and mention bot_token + channel_id instead of webhook URL.\n\
      \n 8. Verify syntax:\n    python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n 9. Quick smoke test - verify class\
      \ can be instantiated without a config file:\n    python3 -c \"\n    import\
      \ importlib.util\n    spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \    mod = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(mod)\n\
      \    notifier = mod.SlackNotifier('/nonexistent/path')\n    assert not notifier.is_enabled(),\
      \ 'Should be disabled with missing config'\n    assert hasattr(notifier, '_post_message'),\
      \ 'Should have _post_message method'\n    assert not hasattr(notifier, '_post_webhook'),\
      \ 'Should NOT have _post_webhook method'\n    print('SlackNotifier transport\
      \ migration verified OK')\n    \"\n\n Files: scripts/plan-orchestrator.py\n"
    attempts: 2
    last_attempt: '2026-02-16T19:54:35.636614'
    model_used: sonnet
    validation_findings: '[PASS] `__init__` correctly loads `bot_token`, `app_token`,
      `channel_id` instead of `webhook_url` — `scripts/plan-orchestrator.py:2566-2568`\n-
      [PASS] `_post_webhook` method fully removed; no references to `_post_webhook`
      or `webhook_url` remain in `scripts/plan-orchestrator.py`\n- [PASS] `_post_message`
      correctly implements `chat.postMessage` with Bearer auth and channel injection
      — `scripts/plan-orchestrator.py:2595-2628`\n- [PASS] `send_status` uses `_post_message`
      with correct guard (`not self._bot_token or not self._channel_id`) — `scripts/plan-orchestrator.py:2655-2659`\n-
      [PASS] `send_defect` calls `_post_message` — `scripts/plan-orchestrator.py:2762`\n-
      [PASS] `send_idea` calls `_post_message` — `scripts/plan-orchestrator.py:2778`\n-
      [PASS] Class docstring updated to mention \"Slack Web API\", Bearer token auth,
      and `bot_token`/`channel_id` — `scripts/plan-orchestrator.py:2528-2535`\n- [PASS]
      Syntax verification passes (py_compile)\n- [PASS] Smoke test passes: disabled
      with missing config, has `_post_message`, no `_post_webhook`\n- [FAIL] 3 test
      failures in `tests/test_slack_notifier.py` — tests still use old `webhook_url`
      config and monkey-patch `_post_webhook` which no longer exists\n  - `test_post_webhook_called_on_send_status`
      — line 170 monkey-patches `_post_webhook` but code now calls `_post_message`\n  -
      `test_process_agent_messages_defect` — line 219 monkey-patches `_post_webhook`\n  -
      `test_process_agent_messages_idea` — line 263 monkey-patches `_post_webhook`\n-
      [WARN] Multiple passing tests still use `webhook_url` in config fixtures (lines
      60, 80, 105, 129, 155, 200, 248, 289, 320) — these happen to pass because the
      notifier ignores unknown config keys, but fixtures should use `bot_token`/`channel_id`
      for correctness\n\n**Evidence:**\n\n- Finding 10 (FAIL): pytest output shows
      3 failures — all in tests that monkey-patch `_post_webhook`. The method was
      renamed to `_post_message` in the implementation, but `tests/test_slack_notifier.py`
      was not updated. The design document (Phase 3, Task 3.1) explicitly states:
      \"Update all config fixtures: replace webhook_url with bot_token + channel_id.
      Replace test_post_webhook_called_on_send_status with test_post_message_called.\"\n-
      Finding 11 (WARN): Grep for `webhook_url` in test file shows 9 config fixtures
      still using the old field. These tests pass coincidentally because the notifier
      simply ignores the unknown key, but they are not testing the correct config
      schema."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":231,"cache_read_input_tokens":43930,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":231},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"99bef4da-c3c3-4fe4-aa54-df9b630f1656","uuid":"c57a431f-3623-487d-906d-c3de91b0caf1"}

      [PASS] `__init__` correctly loads `bot_token`, `app_token`, `channel_id` instead
      of `webhook_url` — `scripts/plan-orchestrator.py:2566-2568`\n- [PASS] `_post_webhook`
      method fully removed; no references to `_post_webhook` or `webhook_url` remain
      in `scripts/plan-orchestrator.py`\n- [PASS] `_post_message` correctly implements
      `chat.postMessage` with Bearer auth and channel injection — `scripts/plan-orchestrator.py:2595-2628`\n-
      [PASS] `send_status` uses `_post_message` with correct guard (`not self._bot_token
      or not self._channel_id`) — `scripts/plan-orchestrator.py:2655-2659`\n- [PASS]
      `send_defect` calls `_post_message` — `scripts/plan-orchestrator.py:2762`\n-
      [PASS] `send_idea` calls `_post_message` — `scripts/plan-orchestrator.py:2778`\n-
      [PASS] Class docstring updated to mention \"Slack Web API\", Bearer token auth,
      and `bot_token`/`channel_id` — `scripts/plan-orchestrator.py:2528-2535`\n- [PASS]
      Syntax verification passes (py_compile)\n- [PASS] Smoke test passes: disabled
      with missing config, has `_post_message`, no `_post_webhook`\n- [FAIL] 3 test
      failures in `tests/test_slack_notifier.py` — tests still use old `webhook_url`
      config and monkey-patch `_post_webhook` which no longer exists\n  - `test_post_webhook_called_on_send_status`
      — line 170 monkey-patches `_post_webhook` but code now calls `_post_message`\n  -
      `test_process_agent_messages_defect` — line 219 monkey-patches `_post_webhook`\n  -
      `test_process_agent_messages_idea` — line 263 monkey-patches `_post_webhook`\n-
      [WARN] Multiple passing tests still use `webhook_url` in config fixtures (lines
      60, 80, 105, 129, 155, 200, 248, 289, 320) — these happen to pass because the
      notifier ignores unknown config keys, but fixtures should use `bot_token`/`channel_id`
      for correctness\n\n**Evidence:**\n\n- Finding 10 (FAIL): pytest output shows
      3 failures — all in tests that monkey-patch `_post_webhook`. The method was
      renamed to `_post_message` in the implementation, but `tests/test_slack_notifier.py`
      was not updated. The design document (Phase 3, Task 3.1) explicitly states:
      \"Update all config fixtures: replace webhook_url with bot_token + channel_id.
      Replace test_post_webhook_called_on_send_status with test_post_message_called.\"\n-
      Finding 11 (WARN): Grep for `webhook_url` in test file shows 9 config fixtures
      still using the old field. These tests pass coincidentally because the notifier
      simply ignores the unknown key, but they are not testing the correct config
      schema.","stop_reason":null,"session_id":"99bef4da-c3c3-4fe4-aa54-df9b630f1656","total_cost_usd":0.31948400000000005,"usage":{"input_tokens":7,"cache_creation_input_tokens":23570,"cache_read_input_tokens":211691,"output_tokens":2249,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":23570,"ephemeral_5m_input_tokens":0},"inference_geo":"","iterations":[],"speed":"standard"},"modelUsage":{"claude-haiku-4-5-20251001":{"inputTokens":9246,"outputTokens":164,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.010066000000000002,"contextWindow":200000,"maxOutputTokens":32000},"claude-opus-4-6":{"inputTokens":7,"outputTokens":2249,"cacheReadInputTokens":211691,"cacheCreationInputTokens":23570,"webSearchRequests":0,"costUSD":0.309418,"contextWindow":200000,"maxOutputTokens":32000}},"permission_denials":[],"uuid":"48a1783f-f2ae-4766-abfc-efcd51cd750a"}'
    validation_attempts: 1
    completed_at: '2026-02-16T19:56:21.169030'
    result_message: Updated SlackNotifier tests to use Web API (bot_token/channel_id)
      instead of webhooks. Replaced all _post_webhook monkey-patches with _post_message.
      All 15 tests pass.
  - id: '2.2'
    name: Add Socket Mode support for interactive questions
    agent: coder
    status: completed
    depends_on:
    - '2.1'
    description: "Add optional Socket Mode support to SlackNotifier for receiving\
      \ interactive button responses on questions.\n Reference: docs/plans/2026-02-16-14-slack-app-migration-design.md\n\
      \ Steps:\n 1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class.\n\
      \n 2. Near the top of the file (after the existing imports, around line 22),\
      \ add an optional import block:\n    try:\n        from slack_bolt import App\n\
      \        from slack_bolt.adapter.socket_mode import SocketModeHandler\n    \
      \    SOCKET_MODE_AVAILABLE = True\n    except ImportError:\n        SOCKET_MODE_AVAILABLE\
      \ = False\n\n 3. In SlackNotifier.__init__, after loading config fields, add:\n\
      \    self._socket_handler = None\n    self._pending_answer = None  # threading.Event\
      \ set when answer received\n    self._last_answer = None     # stores the answer\
      \ value\n\n 4. Add a new method _ensure_socket_mode to start the Socket Mode\
      \ handler:\n    def _ensure_socket_mode(self) -> bool:\n        \"\"\"Start\
      \ Socket Mode handler if available and not already running.\"\"\"\n        if\
      \ not SOCKET_MODE_AVAILABLE:\n            return False\n        if self._socket_handler\
      \ is not None:\n            return True\n        if not self._app_token:\n \
      \           return False\n        try:\n            app = App(token=self._bot_token)\n\
      \            @app.action(re.compile(r\"orchestrator_answer_.*\"))\n        \
      \    def handle_answer(ack, action, body):\n                ack()\n        \
      \        self._last_answer = action.get(\"value\", \"\")\n                if\
      \ self._pending_answer:\n                    self._pending_answer.set()\n  \
      \          handler = SocketModeHandler(app, self._app_token)\n            handler.connect()\
      \  # non-blocking WebSocket connect\n            self._socket_handler = handler\n\
      \            return True\n        except Exception as e:\n            print(f\"\
      [SLACK] Socket Mode failed to start: {e}\")\n            return False\n\n 5.\
      \ Update send_question to use Socket Mode when available:\n    - After the existing\
      \ guard checks, try Socket Mode first:\n      use_socket = self._ensure_socket_mode()\n\
      \    - Build question payload with Block Kit action buttons:\n      actions\
      \ = [{\"type\": \"button\", \"text\": {\"type\": \"plain_text\",\n        \"\
      text\": opt}, \"action_id\": f\"orchestrator_answer_{i}\",\n        \"value\"\
      : opt} for i, opt in enumerate(options)]\n      payload = {\"blocks\": [{\"\
      type\": \"section\", \"text\":\n        {\"type\": \"mrkdwn\", \"text\": f\"\
      :question: *{question}*\"}},\n        {\"type\": \"actions\", \"elements\":\
      \ actions}]}\n    - Post the question via _post_message.\n    - If use_socket\
      \ is True:\n      self._pending_answer = threading.Event()\n      self._last_answer\
      \ = None\n      answered = self._pending_answer.wait(timeout=effective_timeout\
      \ * 60)\n      if answered and self._last_answer:\n          return self._last_answer\n\
      \      return fallback\n    - If use_socket is False: fall back to the existing\
      \ file-based polling (keep the current file polling code as the else branch).\n\
      \n 6. Verify syntax:\n    python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n 7. Verify the SOCKET_MODE_AVAILABLE\
      \ constant exists:\n    python3 -c \"\n    import importlib.util\n    spec =\
      \ importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \    mod = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(mod)\n\
      \    assert hasattr(mod, 'SOCKET_MODE_AVAILABLE')\n    print(f'SOCKET_MODE_AVAILABLE\
      \ = {mod.SOCKET_MODE_AVAILABLE}')\n    notifier = mod.SlackNotifier('/nonexistent/path')\n\
      \    assert hasattr(notifier, '_ensure_socket_mode')\n    print('Socket Mode\
      \ support verified')\n    \"\n\n Files: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-16T19:56:23.255671'
    model_used: sonnet
    completed_at: '2026-02-16T19:59:53.712153'
    result_message: Added Socket Mode support for interactive questions. SlackNotifier
      now uses Block Kit action buttons with WebSocket responses when slack-bolt is
      installed, falling back to file-based polling otherwise.
- id: phase-3
  name: Phase 3 - Unit Tests
  status: completed
  tasks:
  - id: '3.1'
    name: Update unit tests for new Slack App transport
    agent: coder
    status: completed
    depends_on:
    - '2.2'
    description: "Update tests/test_slack_notifier.py for the new Slack App transport.\n\
      \ Reference: docs/plans/2026-02-16-14-slack-app-migration-design.md\n Steps:\n\
      \ 1. Read tests/test_slack_notifier.py and scripts/plan-orchestrator.py to understand\
      \ the current test structure and new SlackNotifier API.\n\n 2. Update ALL config\
      \ fixture dicts throughout the file:\n    - Replace every instance of:\n   \
      \   \"webhook_url\": \"https://hooks.slack.com/services/TEST\"\n      with:\n\
      \      \"bot_token\": \"xoxb-test-token\",\n      \"channel_id\": \"C0123456789\"\
      \n    - This affects: test_enabled_when_config_valid, test_should_notify_respects_config,\n\
      \      test_build_status_block_format, test_build_status_block_default_emoji,\n\
      \      test_post_webhook_called_on_send_status, test_process_agent_messages_defect,\n\
      \      test_process_agent_messages_idea, test_process_agent_messages_empty,\n\
      \      test_process_agent_messages_no_field.\n\n 3. Rename and update test_post_webhook_called_on_send_status:\n\
      \    - Rename to test_post_message_called_on_send_status\n    - Monkey-patch\
      \ _post_message instead of _post_webhook\n    - Assert _post_message was called\
      \ with payload containing blocks\n\n 4. Update all other tests that monkey-patch\
      \ _post_webhook:\n    - test_process_agent_messages_defect: patch _post_message\n\
      \    - test_process_agent_messages_idea: patch _post_message\n    - test_process_agent_messages_empty:\
      \ patch _post_message\n    - test_process_agent_messages_no_field: patch _post_message\n\
      \n 5. Add new test: test_post_message_includes_channel:\n    Create an enabled\
      \ SlackNotifier with channel_id \"C999\".\n    Capture the payload passed to\
      \ urllib.request.Request by monkey-patching\n    urllib.request.urlopen (or\
      \ patch _post_message at a lower level).\n    Call send_status(\"test\").\n\
      \    Verify that the payload includes channel: \"C999\".\n\n 6. Add new test:\
      \ test_socket_mode_available_constant:\n    Assert that mod.SOCKET_MODE_AVAILABLE\
      \ is a bool.\n    (It will be True or False depending on whether slack-bolt\
      \ is installed.)\n\n 7. Add new test: test_send_question_falls_back_to_file_polling:\n\
      \    Create an enabled SlackNotifier with questions enabled.\n    Patch _post_message\
      \ to return True.\n    Patch _ensure_socket_mode to return False.\n    Set a\
      \ short timeout (e.g., 1 second by setting timeout_minutes=0\n    and question\
      \ config timeout to a tiny value, or mock time.sleep\n    and time.time to simulate\
      \ timeout).\n    Call send_question - it should return the fallback value.\n\
      \n 8. Add new test: test_enabled_requires_bot_token_and_channel_id:\n    Create\
      \ a config with enabled: true but no bot_token.\n    Verify send_status is a\
      \ no-op (does not call _post_message).\n    Create a config with bot_token but\
      \ no channel_id.\n    Verify send_status is a no-op.\n\n 9. Update test_slack_config_constants_exist:\
      \ add assertion for\n    SOCKET_MODE_AVAILABLE existing in the module.\n\n 10.\
      \ Run tests and fix any failures:\n     python3 -m pytest tests/test_slack_notifier.py\
      \ -v\n\n Files: tests/test_slack_notifier.py\n"
    attempts: 1
    last_attempt: '2026-02-16T19:59:55.797440'
    model_used: sonnet
    completed_at: '2026-02-16T20:04:14.319849'
    result_message: Updated unit tests for new Slack App transport. All config fixtures
      updated to use bot_token/channel_id, added tests for _post_message, Socket Mode
      availability, and fallback behavior. All 19 tests passing.
- id: phase-4
  name: Phase 4 - Verification
  status: pending
  tasks:
  - id: '4.1'
    name: Verify syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '3.1'
    description: "Run verification checks to confirm the Slack App migration works\
      \ correctly.\n Steps:\n 1. Check Python syntax for both scripts:\n    python3\
      \ -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py', doraise=True);\
      \ py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\n\n 2.\
      \ Run all unit tests:\n    python3 -m pytest tests/ 2>/dev/null || echo 'No\
      \ test suite configured'\n\n 3. Verify SlackNotifier class has new transport\
      \ methods:\n    python3 -c \"\n    import importlib.util\n    spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n    mod = importlib.util.module_from_spec(spec)\n\
      \    spec.loader.exec_module(mod)\n    notifier = mod.SlackNotifier('/nonexistent')\n\
      \    assert not notifier.is_enabled()\n    assert hasattr(notifier, '_post_message'),\
      \ 'Missing _post_message'\n    assert not hasattr(notifier, '_post_webhook'),\
      \ 'Should not have _post_webhook'\n    assert hasattr(notifier, '_ensure_socket_mode'),\
      \ 'Missing _ensure_socket_mode'\n    assert hasattr(notifier, 'send_status')\n\
      \    assert hasattr(notifier, 'send_question')\n    assert hasattr(notifier,\
      \ 'send_defect')\n    assert hasattr(notifier, 'send_idea')\n    assert hasattr(notifier,\
      \ 'process_agent_messages')\n    print('SlackNotifier class verified: all new\
      \ methods present, webhook removed')\n    \"\n\n 4. Verify config template has\
      \ new fields:\n    python3 -c \"\n    import yaml\n    with open('.claude/slack.local.yaml.template')\
      \ as f:\n        config = yaml.safe_load(f)\n    assert 'bot_token' in config['slack'],\
      \ 'Missing bot_token'\n    assert 'app_token' in config['slack'], 'Missing app_token'\n\
      \    assert 'channel_id' in config['slack'], 'Missing channel_id'\n    assert\
      \ 'webhook_url' not in config['slack'], 'webhook_url should be removed'\n  \
      \  print('Config template validated OK')\n    \"\n\n 5. Verify .gitignore still\
      \ has Slack patterns:\n    python3 -c \"\n    with open('.gitignore') as f:\n\
      \        content = f.read()\n    assert 'slack.local.yaml' in content, '.gitignore\
      \ missing slack.local.yaml'\n    assert 'slack-*.json' in content, '.gitignore\
      \ missing slack-*.json'\n    print('.gitignore patterns verified')\n    \"\n\
      \n 6. Run orchestrator dry-run to verify no startup errors:\n    python3 scripts/plan-orchestrator.py\
      \ --plan .claude/plans/sample-plan.yaml --dry-run\n\n If any check fails, report\
      \ the failure with specific details.\n Files: scripts/plan-orchestrator.py,\
      \ scripts/auto-pipeline.py, .claude/slack.local.yaml.template, .gitignore, tests/test_slack_notifier.py\n"
