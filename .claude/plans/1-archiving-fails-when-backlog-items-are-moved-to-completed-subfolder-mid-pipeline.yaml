meta:
  name: Fix Archiving Failure When Backlog Items Are Moved to completed/ Subfolder
    Mid-Pipeline
  description: 'archive_item() uses item.path captured at scan time. If a consumer
    project''s orchestrator moves the file into a completed/ subfolder inside the
    backlog directory between scan and archive, shutil.move raises FileNotFoundError.
    Fix: add _resolve_item_path() helper that probes the completed/ subfolder as a
    fallback before giving up.'
  plan_doc: docs/plans/2026-02-18-1-archiving-fails-when-backlog-items-are-moved-to-completed-subfolder-mid-pipeline-design.md
  created: '2026-02-18'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - issue-verifier
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Implementation
  status: completed
  tasks:
  - id: '1.1'
    name: Add _resolve_item_path() helper and update archive_item()
    agent: coder
    status: completed
    description: "Add a _resolve_item_path() helper function to scripts/auto-pipeline.py\
      \ and update\narchive_item() to use it, so that archiving succeeds even when\
      \ the consumer project\nhas moved the backlog file to a completed/ subfolder.\n\
      \nReference: docs/plans/2026-02-18-1-archiving-fails-when-backlog-items-are-moved-to-completed-subfolder-mid-pipeline-design.md\n\
      \nSteps:\n1. Read scripts/auto-pipeline.py. Locate archive_item() (around line\
      \ 1375).\n   Also note the COMPLETED_DIRS constant near line 61.\n\n2. Just\
      \ above the archive_item() function definition, add the following helper:\n\n\
      \     def _resolve_item_path(item: \"BacklogItem\") -> Optional[str]:\n    \
      \     \"\"\"Locate the actual file path for a backlog item at archive time.\n\
      \n         Returns item.path if the file exists there. Falls back to checking\n\
      \         <backlog_dir>/completed/<filename> in case an external process relocated\n\
      \         the file mid-pipeline. Returns None if the file cannot be found at\
      \ either\n         location.\n         \"\"\"\n         if os.path.exists(item.path):\n\
      \             return item.path\n         candidate = os.path.join(\n       \
      \      os.path.dirname(item.path), \"completed\", os.path.basename(item.path)\n\
      \         )\n         if os.path.exists(candidate):\n             log(f\"[ARCHIVE]\
      \ Item relocated to completed/ subfolder, using: {candidate}\")\n          \
      \   return candidate\n         return None\n\n3. Update archive_item() to call\
      \ _resolve_item_path() before shutil.move().\n   Replace the existing function\
      \ body with:\n\n     def archive_item(item: BacklogItem, dry_run: bool = False)\
      \ -> bool:\n         \"\"\"Move a completed backlog item to the top-level archive\
      \ directory.\"\"\"\n         dest_dir = COMPLETED_DIRS[item.item_type]\n   \
      \      dest = os.path.join(dest_dir, os.path.basename(item.path))\n\n      \
      \   if dry_run:\n             log(f\"[DRY RUN] Would archive: {item.path} ->\
      \ {dest}\")\n             return True\n\n         source = _resolve_item_path(item)\n\
      \         if source is None:\n             log(f\"WARNING: Cannot archive {item.path}:\
      \ file not found at original path or completed/ subfolder\")\n             return\
      \ False\n\n         try:\n             os.makedirs(dest_dir, exist_ok=True)\n\
      \             shutil.move(source, dest)\n\n             # Git commit the move\n\
      \             subprocess.run([\"git\", \"add\", source, dest], capture_output=True,\
      \ check=True)\n             subprocess.run(\n                 [\"git\", \"commit\"\
      , \"-m\", f\"chore: archive completed {item.item_type} {item.slug}\"],\n   \
      \              capture_output=True, check=True,\n             )\n          \
      \   log(f\"Archived: {source} -> {dest}\")\n             return True\n     \
      \    except (OSError, subprocess.CalledProcessError) as e:\n             log(f\"\
      WARNING: Failed to archive {source}: {e}\")\n             return False\n\n4.\
      \ Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); print('syntax OK')\"\n\n5. Verify _resolve_item_path is importable:\n\
      \   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('ap',\
      \ 'scripts/auto-pipeline.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   assert hasattr(mod, '_resolve_item_path'),\
      \ 'Missing _resolve_item_path'\n   print('_resolve_item_path found OK')\n  \
      \ \"\n\nFiles: scripts/auto-pipeline.py\n"
    attempts: 1
    last_attempt: '2026-02-18T08:17:30.571224'
    model_used: sonnet
    completed_at: '2026-02-18T08:19:57.186210'
    result_message: Added _resolve_item_path() helper above archive_item(). archive_item()
      now resolves the actual source path before shutil.move(), falling back to <backlog_dir>/completed/<filename>
      if the original path no longer exists. All 204 tests pass.
- id: phase-2
  name: Phase 2 - Unit Tests
  status: pending
  tasks:
  - id: '2.1'
    name: Add unit tests for _resolve_item_path() and archive_item() fallback
    agent: coder
    status: pending
    depends_on:
    - '1.1'
    description: "Add unit tests for the new _resolve_item_path() helper and the updated\
      \ archive_item()\nfallback behavior to tests/test_auto_pipeline.py.\n\nReference:\
      \ docs/plans/2026-02-18-1-archiving-fails-when-backlog-items-are-moved-to-completed-subfolder-mid-pipeline-design.md\n\
      \nSteps:\n1. Read tests/test_auto_pipeline.py to understand existing test structure\
      \ and imports.\n   Note: the module is loaded via importlib (because of the\
      \ hyphen in the filename).\n   Find the mod variable and the existing import\
      \ list (compact_plan_label, etc.).\n\n2. Add the following to the import list\
      \ at the top of the file:\n     _resolve_item_path = mod._resolve_item_path\n\
      \     archive_item = mod.archive_item\n     BacklogItem = mod.BacklogItem\n\n\
      3. Add a new test section at the end of the file with these test cases:\n\n\
      \   a. test_resolve_item_path_file_at_original_location(tmp_path):\n      -\
      \ Create tmp_path / \"defect-backlog\" / \"my-item.md\" with some content.\n\
      \      - Create a BacklogItem with path=str(that file), item_type=\"defect\"\
      , slug=\"my-item\", name=\"My Item\".\n      - Assert _resolve_item_path(item)\
      \ == str(that file).\n\n   b. test_resolve_item_path_file_in_completed_subfolder(tmp_path):\n\
      \      - Create directory tmp_path / \"defect-backlog\" / \"completed\".\n \
      \     - Place \"my-item.md\" inside the completed subfolder (NOT at the root).\n\
      \      - Create a BacklogItem with path pointing to the root (non-existent)\
      \ location.\n      - Assert _resolve_item_path(item) == str(completed/my-item.md).\n\
      \n   c. test_resolve_item_path_file_not_found(tmp_path):\n      - Create a BacklogItem\
      \ with a path that does not exist anywhere.\n      - Assert _resolve_item_path(item)\
      \ is None.\n\n   d. test_archive_item_succeeds_when_file_in_completed_subfolder(tmp_path,\
      \ monkeypatch):\n      - Create tmp_path / \"defect-backlog\" / \"completed\"\
      \ / \"my-item.md\" with dummy content.\n      - Create BacklogItem with path=str(tmp_path\
      \ / \"defect-backlog\" / \"my-item.md\") (stale).\n      - Set up COMPLETED_DEFECTS_DIR-equivalent\
      \ destination inside tmp_path.\n      - Monkeypatch mod.COMPLETED_DIRS to point\
      \ to a temp archive dir.\n      - Monkeypatch subprocess.run to no-op (avoid\
      \ real git calls).\n      - Call archive_item(item, dry_run=False).\n      -\
      \ Assert the function returns True.\n      - Assert the destination file exists\
      \ in the archive dir.\n\n   e. test_archive_item_returns_false_when_file_not_found(tmp_path,\
      \ monkeypatch):\n      - Create BacklogItem with a path that does not exist\
      \ (no completed/ subfolder either).\n      - Monkeypatch mod.COMPLETED_DIRS\
      \ and subprocess.run.\n      - Call archive_item(item, dry_run=False).\n   \
      \   - Assert the function returns False.\n\n   f. test_archive_item_dry_run_does_not_require_file(tmp_path):\n\
      \      - Create BacklogItem with a non-existent path.\n      - Call archive_item(item,\
      \ dry_run=True).\n      - Assert the function returns True (dry run never touches\
      \ disk).\n\n4. Run tests:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/test_auto_pipeline.py -v\n   Fix any failures.\n\nFiles: tests/test_auto_pipeline.py\n"
- id: phase-3
  name: Phase 3 - Verification
  status: pending
  tasks:
  - id: '3.1'
    name: Final verification - syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '2.1'
    description: "Run verification checks to confirm the fix is correct and all tests\
      \ pass.\n\nSteps:\n1. Check Python syntax for both scripts:\n   python3 -c \"\
      import py_compile; py_compile.compile('scripts/auto-pipeline.py', doraise=True);\
      \ py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\n\n2. Run\
      \ the full test suite:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest tests/\
      \ 2>/dev/null || echo 'No test suite configured'\n\n3. Verify _resolve_item_path\
      \ is present and behaves correctly with a quick smoke test:\n   python3 -c \"\
      \n   import importlib.util, tempfile, os\n   from pathlib import Path\n   spec\
      \ = importlib.util.spec_from_file_location('ap', 'scripts/auto-pipeline.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \n   with tempfile.TemporaryDirectory() as tmp:\n       # Case 1: file at original\
      \ path\n       f = Path(tmp) / 'item.md'\n       f.write_text('content')\n \
      \      item = mod.BacklogItem(path=str(f), name='Item', slug='item', item_type='defect')\n\
      \       assert mod._resolve_item_path(item) == str(f), 'Should find at original\
      \ path'\n\n       # Case 2: file moved to completed/\n       comp = Path(tmp)\
      \ / 'completed'\n       comp.mkdir()\n       moved = comp / 'item2.md'\n   \
      \    moved.write_text('content')\n       item2 = mod.BacklogItem(path=str(Path(tmp)\
      \ / 'item2.md'), name='Item2', slug='item2', item_type='defect')\n       assert\
      \ mod._resolve_item_path(item2) == str(moved), 'Should find in completed/ subfolder'\n\
      \n       # Case 3: file not found anywhere\n       item3 = mod.BacklogItem(path=str(Path(tmp)\
      \ / 'ghost.md'), name='Ghost', slug='ghost', item_type='defect')\n       assert\
      \ mod._resolve_item_path(item3) is None, 'Should return None when not found'\n\
      \n   print('_resolve_item_path smoke test OK')\n   \"\n\n4. Run orchestrator\
      \ dry-run to confirm no startup errors:\n   python3 scripts/plan-orchestrator.py\
      \ --plan .claude/plans/sample-plan.yaml --dry-run\n\nIf any check fails, report\
      \ the specific failure with details.\n\nFiles: scripts/auto-pipeline.py, scripts/plan-orchestrator.py,\
      \ tests/test_auto_pipeline.py\n"
