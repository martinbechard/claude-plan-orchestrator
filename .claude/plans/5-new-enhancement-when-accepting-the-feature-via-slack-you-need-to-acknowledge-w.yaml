meta:
  name: 'Feature: Slack Intake Acknowledgment with Analysis Summary'
  description: 'Add a two-phase acknowledgment flow to the Slack intake pipeline.
    Phase 1: send an immediate "Analyzing..." message when a feature/defect request
    is received. Phase 2: send an analysis summary (title, classification, root need)
    after the 5 Whys analysis completes but before creating the backlog item. This
    gives the user a confirmation checkpoint to verify alignment before work begins.

    '
  plan_doc: docs/plans/2026-02-17-5-new-enhancement-when-accepting-the-feature-via-slack-you-need-to-acknowledge-w-design.md
  created: '2026-02-17'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Implementation
  status: pending
  tasks:
  - id: '1.1'
    name: Add INTAKE_ACK_TEMPLATE constant and acknowledgment messages
    agent: coder
    status: pending
    description: "In scripts/plan-orchestrator.py, add a new constant and two\
      \ send_status() calls to _run_intake_analysis() to provide intake acknowledgment.\n\
      \nStep 1: Add constant INTAKE_ACK_TEMPLATE after line 218 (after INTAKE_ANALYSIS_TIMEOUT_SECONDS):\n\
      \n    INTAKE_ACK_TEMPLATE = (\n        \"*Here is my understanding of your {item_type}:*\\\
      n\"\n        \"\\n\"\n        \"*Title:* {title}\\n\"\n        \"*Classification:*\
      \ {classification}\\n\"\n        \"*Root need:* {root_need}\\n\"\n        \"\\\
      n\"\n        \"_Creating backlog item..._\"\n    )\n\nStep 2: In _run_intake_analysis()\
      \ (currently at line ~3740), add an immediate acknowledgment right\n\
      after the fallback_title assignment (line ~3751) and before the try block's\
      \ LLM call:\n\n    # Send immediate acknowledgment\n    try:\n        self.send_status(\n\
      \            f\"*Received your {intake.item_type} request.* Analyzing...\",\n\
      \            level=\"info\", channel_id=intake.channel_id,\n        )\n    except\
      \ Exception:\n        pass  # Best-effort, do not block analysis\n\nIMPORTANT:\
      \ This must go INSIDE the existing try block, right after\n    fallback_title\
      \ = intake.original_text.split(\"\\n\", 1)[0][:80]\n\
      and BEFORE the Step 1 comment about calling Claude CLI. Wrap the send_status\
      \ in its own try/except so a Slack failure does not abort analysis.\n\nStep 3:\
      \ In _run_intake_analysis(), add the analysis summary message AFTER the\n5 Whys\
      \ retry validation block (after line ~3815 where the WARNING is printed) and\n\
      BEFORE the description-building step (line ~3817). Insert:\n\n    # Send analysis\
      \ summary before creating backlog item\n    try:\n        ack_msg = INTAKE_ACK_TEMPLATE.format(\n\
      \            item_type=intake.item_type,\n            title=title,\n          \
      \  classification=classification or \"unknown\",\n            root_need=root_need\
      \ or \"not identified\",\n        )\n        self.send_status(ack_msg, level=\"\
      info\", channel_id=intake.channel_id)\n    except Exception:\n        pass  #\
      \ Best-effort, do not block backlog creation\n\nStep 4: Verify syntax:\n  python3\
      \ -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True)\"\n"
- id: phase-2
  name: Phase 2 - Tests
  status: pending
  tasks:
  - id: '2.1'
    name: Add unit tests for intake acknowledgment messages
    agent: coder
    depends_on:
    - '1.1'
    status: pending
    description: "Add tests to tests/test_plan_orchestrator.py for the new\
      \ acknowledgment messages in _run_intake_analysis().\n\nFirst read the existing\
      \ tests in tests/test_plan_orchestrator.py to understand the import pattern,\
      \ mock setup, and helper functions (e.g., build_intake_response).\n\nAdd the\
      \ following test functions:\n\n1. test_intake_sends_immediate_ack:\n   Create\
      \ a mock SlackNotifier with _call_claude_print returning a complete response\n\
      \   (5 Whys via build_intake_response). Mock send_status and create_backlog_item.\n\
      \   Call _run_intake_analysis(intake).\n   Assert send_status was called at least\
      \ once with a message containing \"Received your feature request\" and\n   level=\"\
      info\" BEFORE the success-level call.\n   Verify the first send_status call (call_args_list[0])\
      \ contains the ack.\n\n2. test_intake_sends_analysis_summary:\n   Same setup\
      \ as above. After calling _run_intake_analysis(intake),\n   check send_status\
      \ call_args_list for a call containing \"Here is my understanding\".\n   Verify\
      \ it includes the title, classification, and root need from the parsed response.\n\
      \   Verify this call happens before the final success call.\n\n3. test_intake_ack_on_empty_response:\n\
      \   Mock _call_claude_print to return \"\" (empty). Mock send_status and\n  \
      \ create_backlog_item.\n   Call _run_intake_analysis(intake).\n   Verify send_status\
      \ was still called with the immediate ack (\"Received your\").\n   The analysis\
      \ summary should NOT be sent since there was no analysis.\n\n4. test_intake_ack_on_analysis_error:\n\
      \   Mock _call_claude_print to raise an Exception.\n   Call _run_intake_analysis(intake).\n\
      \   Verify the immediate ack (\"Received your\") was sent before the error.\n\
      \   The analysis summary is not sent because the error happens before that point.\n\
      \nAfter writing tests, run them:\n  ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/test_plan_orchestrator.py -v\n\nFix any failures immediately.\n"
- id: phase-3
  name: Phase 3 - Verification
  status: pending
  tasks:
  - id: '3.1'
    name: Verify syntax and run full test suite
    agent: code-reviewer
    depends_on:
    - '2.1'
    status: pending
    description: "Run the following verification steps:\n\n1. Compile-check both\
      \ main scripts:\n   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run the full test suite:\n   python3 -m pytest tests/ 2>/dev/null || echo\
      \ 'No test suite configured'\n\n3. Verify INTAKE_ACK_TEMPLATE constant exists:\n\
      \   grep -n 'INTAKE_ACK_TEMPLATE' scripts/plan-orchestrator.py\n   Expected:\
      \ at least 2 matches (definition + usage in _run_intake_analysis).\n\n4. Verify\
      \ immediate acknowledgment is sent:\n   grep -n 'Received your.*request.*Analyzing'\
      \ scripts/plan-orchestrator.py\n   Expected: 1 match in _run_intake_analysis.\n\
      \n5. Verify analysis summary is sent:\n   grep -n 'INTAKE_ACK_TEMPLATE.format'\
      \ scripts/plan-orchestrator.py\n   Expected: 1 match in _run_intake_analysis.\n\
      \n6. Verify acknowledgment tests exist:\n   grep -n 'def test_intake.*ack\\|def\
      \ test_intake.*summary\\|def test_intake.*immediate' tests/test_plan_orchestrator.py\n\
      \   Expected: at least 3 test functions.\n\n7. Verify send_status is called 3\
      \ times in the happy path:\n   Count send_status calls in _run_intake_analysis\
      \ main path (not error handler):\n   grep -n 'send_status' scripts/plan-orchestrator.py\
      \ | grep -A0 -B0 ''\n   Expected: at least 3 send_status calls within _run_intake_analysis\
      \ method.\n\nReport findings as PASS/WARN/FAIL.\n"
