meta:
  name: Add Configurable Conversation History for Follow-on Question Support
  description: 'Extend SlackNotifier.answer_question() to maintain a rolling window
    of prior Q&A exchanges and inject that history into each new question''s prompt.
    The window size is configurable in slack.local.yaml (default: 3 turns). This enables
    iterative, follow-on questions without requiring users to restate background context
    each time.'
  plan_doc: docs/plans/2026-02-18-1-add-configurable-conversation-history-for-follow-on-question-support-design.md
  created: '2026-02-18'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Core Implementation
  status: in_progress
  tasks:
  - id: '1.1'
    name: Add QA_HISTORY_DEFAULT_MAX_TURNS constant and update SlackNotifier init
    agent: coder
    status: completed
    description: "Add the history constant and new instance fields to SlackNotifier\
      \ in\nscripts/plan-orchestrator.py.\n\nReference: docs/plans/2026-02-18-1-add-configurable-conversation-history-for-follow-on-question-support-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the block of Slack constants\n\
      \   (around lines 74-121, near QUESTION_ANSWER_TIMEOUT_SECONDS).\n\n2. After\
      \ the line:\n     QUESTION_ANSWER_TIMEOUT_SECONDS = 60  # 1 minute for question\
      \ answering\n   Add:\n     QA_HISTORY_DEFAULT_MAX_TURNS = 3  # Default rolling\
      \ window size for Q&A history\n\n3. Read the SlackNotifier.__init__ method (around\
      \ line 2788).\n   At the end of the instance variable initializations block\
      \ (just before\n   the \"try:\" that reads the config file), add two new fields:\n\
      \     self._qa_history: list[tuple[str, str]] = []\n     self._qa_history_enabled:\
      \ bool = True\n     self._qa_history_max_turns: int = QA_HISTORY_DEFAULT_MAX_TURNS\n\
      \n4. Inside the config-reading try block, after the line that reads\n   self._question_config\
      \ (around line 2830), add config parsing for the\n   new conversation_history\
      \ section:\n     conv_config = slack_config.get(\"conversation_history\", {})\n\
      \     if isinstance(conv_config, dict):\n         self._qa_history_enabled =\
      \ bool(conv_config.get(\"enabled\", True))\n         self._qa_history_max_turns\
      \ = int(\n             conv_config.get(\"max_turns\", QA_HISTORY_DEFAULT_MAX_TURNS)\n\
      \         )\n\n5. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n6. Verify constant and new fields exist:\n\
      \   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   assert hasattr(mod, 'QA_HISTORY_DEFAULT_MAX_TURNS'),\
      \ 'Missing QA_HISTORY_DEFAULT_MAX_TURNS'\n   assert mod.QA_HISTORY_DEFAULT_MAX_TURNS\
      \ == 3, 'Wrong default value'\n   n = mod.SlackNotifier('/nonexistent')\n  \
      \ assert hasattr(n, '_qa_history'), 'Missing _qa_history'\n   assert n._qa_history\
      \ == [], 'Should start empty'\n   assert hasattr(n, '_qa_history_enabled'),\
      \ 'Missing _qa_history_enabled'\n   assert hasattr(n, '_qa_history_max_turns'),\
      \ 'Missing _qa_history_max_turns'\n   assert n._qa_history_max_turns == 3, 'Wrong\
      \ default max_turns'\n   print('Constant and init fields verified OK')\n   \"\
      \n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T08:01:47.251908'
    model_used: sonnet
    completed_at: '2026-02-18T08:03:27.969525'
    result_message: Added QA_HISTORY_DEFAULT_MAX_TURNS = 3 constant after QUESTION_ANSWER_TIMEOUT_SECONDS.
      Added _qa_history, _qa_history_enabled, and _qa_history_max_turns fields to
      SlackNotifier.__init__ (before try block). Added conversation_history config
      parsing inside try block after _question_config.
  - id: '1.2'
    name: Update QUESTION_ANSWER_PROMPT with history_context placeholder
    agent: coder
    status: completed
    depends_on:
    - '1.1'
    description: "Update the QUESTION_ANSWER_PROMPT constant to include a {history_context}\n\
      placeholder in scripts/plan-orchestrator.py.\n\nReference: docs/plans/2026-02-18-1-add-configurable-conversation-history-for-follow-on-question-support-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find QUESTION_ANSWER_PROMPT\
      \ (around line 101).\n   The current prompt starts with:\n     \"\"\"You are\
      \ an AI pipeline orchestrator answering a human's question via Slack.\n\n  \
      \   Here is the current pipeline state:\n\n     {state_context}\n   ...\n  \
      \   Human's question: {question}\n\n     Answer:\"\"\"\n\n2. Replace the QUESTION_ANSWER_PROMPT\
      \ constant so that it starts with\n   {history_context} before the \"Here is\
      \ the current pipeline state:\" line:\n\n   QUESTION_ANSWER_PROMPT = \"\"\"\
      You are an AI pipeline orchestrator answering a human's question via Slack.\n\
      \n   {history_context}Here is the current pipeline state:\n\n   {state_context}\n\
      \n   Important context:\n   - The human runs you via Claude Code on a Max subscription,\
      \ NOT the direct API.\n   - The \"total_cost_usd\" in session logs is an API-equivalent\
      \ estimate reported by\n     Claude CLI. It does NOT represent actual charges\
      \ for subscription users. If asked\n     about costs, explain this clearly.\n\
      \   - Keep your answer concise (2-6 lines) and conversational. Use Slack mrkdwn\
      \ formatting\n     (*bold*, _italic_) sparingly.\n   - Only include information\
      \ relevant to the question. Do not dump all available data.\n   - If you genuinely\
      \ cannot answer from the available state, say so honestly.\n\n   Human's question:\
      \ {question}\n\n   Answer:\"\"\"\n\n   IMPORTANT: Preserve the exact original\
      \ wording of all other lines.\n   Only prepend {history_context} before \"Here\
      \ is the current pipeline state:\".\n\n3. Verify syntax:\n   python3 -c \"import\
      \ py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True);\
      \ print('syntax OK')\"\n\n4. Verify the placeholder exists in the prompt:\n\
      \   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   assert '{history_context}' in mod.QUESTION_ANSWER_PROMPT,\
      \ 'Missing {history_context} in prompt'\n   assert '{state_context}' in mod.QUESTION_ANSWER_PROMPT,\
      \ 'Missing {state_context}'\n   assert '{question}' in mod.QUESTION_ANSWER_PROMPT,\
      \ 'Missing {question}'\n   print('QUESTION_ANSWER_PROMPT placeholders verified\
      \ OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 2
    last_attempt: '2026-02-18T08:05:20.003705'
    model_used: sonnet
    validation_findings: 'Validator ''validator'' failed to execute: FAIL: {history_context}
      added to prompt but answer_question() at line 3778 does not pass history_context=
      to .format(), causing KeyError. 3 tests fail.'
    validation_attempts: 1
    completed_at: '2026-02-18T08:06:40.228044'
    result_message: Added {history_context} placeholder to QUESTION_ANSWER_PROMPT
      and updated answer_question() to pass history_context='' to .format(). All 194
      tests pass.
  - id: '1.3'
    name: Update answer_question() to inject and record history
    agent: coder
    status: in_progress
    depends_on:
    - '1.2'
    description: "Update answer_question() in SlackNotifier to build and inject conversation\n\
      history into the prompt, then record the new exchange.\n\nReference: docs/plans/2026-02-18-1-add-configurable-conversation-history-for-follow-on-question-support-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the answer_question method\
      \ (around\n   line 3755). It currently looks like:\n\n     def answer_question(self,\
      \ question: str,\n                         channel_id: Optional[str] = None)\
      \ -> None:\n         print(f\"[SLACK] Answering question: {question[:80]}\"\
      )\n\n         state = self._gather_pipeline_state()\n         state_context\
      \ = self._format_state_context(state)\n         prompt = QUESTION_ANSWER_PROMPT.format(\n\
      \             state_context=state_context, question=question\n         )\n\n\
      \         try:\n             answer = self._call_claude_print(prompt)\n    \
      \         if not answer:\n                 answer = f\"_(LLM returned empty)_\\\
      n{state_context}\"\n         except Exception as e:\n             print(f\"\
      [SLACK] LLM answer failed: {e}\")\n             answer = f\"_(LLM unavailable)_\\\
      n{state_context}\"\n\n         print(f\"[SLACK] Answer: {answer[:120]}\")\n\
      \         self.send_status(answer, level=\"info\", channel_id=channel_id)\n\n\
      2. Replace the method body to:\n   a. Build history_context from self._qa_history\
      \ before formatting the prompt.\n   b. Format the prompt with all three placeholders.\n\
      \   c. After a successful answer, append (question, answer) to self._qa_history\n\
      \      and trim to self._qa_history_max_turns.\n\n   New implementation:\n\n\
      \     def answer_question(self, question: str,\n                         channel_id:\
      \ Optional[str] = None) -> None:\n         \"\"\"Respond to a question from\
      \ Slack using an LLM call with pipeline context.\n\n         Maintains a rolling\
      \ window of prior Q&A exchanges (size configured by\n         self._qa_history_max_turns)\
      \ and injects that history into each prompt.\n\n         Args:\n           \
      \  question: The question text\n             channel_id: Reply to this channel.\
      \ Falls back to default.\n         \"\"\"\n         print(f\"[SLACK] Answering\
      \ question: {question[:80]}\")\n\n         # Build conversation history context\
      \ for the prompt\n         history_context = \"\"\n         if (self._qa_history_enabled\n\
      \                 and self._qa_history_max_turns > 0\n                 and self._qa_history):\n\
      \             lines = [\"Prior conversation:\"]\n             for prior_q, prior_a\
      \ in self._qa_history:\n                 lines.append(f\"Q: {prior_q}\")\n \
      \                lines.append(f\"A: {prior_a}\")\n             lines.append(\"\
      \")\n             history_context = \"\\n\".join(lines) + \"\\n\"\n\n      \
      \   state = self._gather_pipeline_state()\n         state_context = self._format_state_context(state)\n\
      \         prompt = QUESTION_ANSWER_PROMPT.format(\n             history_context=history_context,\n\
      \             state_context=state_context,\n             question=question,\n\
      \         )\n\n         try:\n             answer = self._call_claude_print(prompt)\n\
      \             if not answer:\n                 answer = f\"_(LLM returned empty)_\\\
      n{state_context}\"\n         except Exception as e:\n             print(f\"\
      [SLACK] LLM answer failed: {e}\")\n             answer = f\"_(LLM unavailable)_\\\
      n{state_context}\"\n\n         print(f\"[SLACK] Answer: {answer[:120]}\")\n\
      \         self.send_status(answer, level=\"info\", channel_id=channel_id)\n\n\
      \         # Record this exchange in the rolling history window\n         if\
      \ self._qa_history_enabled and self._qa_history_max_turns > 0:\n           \
      \  self._qa_history.append((question, answer))\n             if len(self._qa_history)\
      \ > self._qa_history_max_turns:\n                 self._qa_history = self._qa_history[-self._qa_history_max_turns:]\n\
      \n3. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n4. Verify the history injection logic\
      \ by smoke-testing:\n   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   n = mod.SlackNotifier('/nonexistent')\n\
      \   # Should start empty\n   assert n._qa_history == []\n\n   # Simulate recording\
      \ an exchange directly\n   n._qa_history.append(('What is the status?', 'Pipeline\
      \ is idle.'))\n   assert len(n._qa_history) == 1\n\n   # Simulate trimming when\
      \ over limit\n   n._qa_history_max_turns = 2\n   for i in range(5):\n      \
      \ n._qa_history.append((f'Q{i}', f'A{i}'))\n       if len(n._qa_history) > n._qa_history_max_turns:\n\
      \           n._qa_history = n._qa_history[-n._qa_history_max_turns:]\n   assert\
      \ len(n._qa_history) == 2, f'Expected 2 entries, got {len(n._qa_history)}'\n\
      \   assert n._qa_history[-1] == ('Q4', 'A4'), 'Last entry should be most recent'\n\
      \   print('answer_question history logic verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T08:06:42.731630'
- id: phase-2
  name: Phase 2 - Config Template Update
  status: pending
  tasks:
  - id: '2.1'
    name: Document conversation_history config in slack.local.yaml.template
    agent: coder
    status: pending
    depends_on:
    - '1.3'
    description: "Add the conversation_history configuration block to the slack.local.yaml.template\n\
      so new users discover the feature immediately.\n\nSteps:\n1. Read .claude/slack.local.yaml.template.\n\
      \n2. After the existing \"questions:\" block at the end of the file, add:\n\
      \     conversation_history:\n       enabled: true          # Set to false to\
      \ disable rolling history\n       max_turns: 3           # Number of prior Q&A\
      \ turns to include in each prompt (0 = disabled)\n\n3. Verify the file is valid\
      \ YAML:\n   python3 -c \"\n   import yaml\n   with open('.claude/slack.local.yaml.template')\
      \ as f:\n       config = yaml.safe_load(f)\n   assert 'conversation_history'\
      \ in config['slack'], 'Missing conversation_history block'\n   assert config['slack']['conversation_history']['max_turns']\
      \ == 3\n   assert config['slack']['conversation_history']['enabled'] is True\n\
      \   print('Template validated OK with conversation_history block')\n   \"\n\n\
      Files: .claude/slack.local.yaml.template\n"
- id: phase-3
  name: Phase 3 - Unit Tests
  status: pending
  tasks:
  - id: '3.1'
    name: Add unit tests for history accumulation, trimming, injection, and config
    agent: coder
    status: pending
    depends_on:
    - '2.1'
    description: "Add unit tests for the new conversation history feature to\ntests/test_slack_notifier.py.\n\
      \nReference: docs/plans/2026-02-18-1-add-configurable-conversation-history-for-follow-on-question-support-design.md\n\
      \nSteps:\n1. Read tests/test_slack_notifier.py to understand the test structure\
      \ and\n   imports. Find the \"Tests for answer_question (LLM-powered)\" section\n\
      \   (near the end of the file) and the _make_notifier() helper.\n\n2. Read scripts/plan-orchestrator.py\
      \ to confirm the answer_question and\n   QUESTION_ANSWER_PROMPT implementations.\n\
      \n3. Add the following test cases at the end of the file, after the last\n \
      \  existing test in the answer_question section:\n\n   a. test_qa_history_constant_exists:\n\
      \      Load the module. Assert hasattr(mod, 'QA_HISTORY_DEFAULT_MAX_TURNS').\n\
      \      Assert mod.QA_HISTORY_DEFAULT_MAX_TURNS == 3.\n\n   b. test_qa_history_initial_state(tmp_path):\n\
      \      Create notifier with _make_notifier(tmp_path).\n      Assert notifier._qa_history\
      \ == [].\n      Assert notifier._qa_history_enabled is True.\n      Assert notifier._qa_history_max_turns\
      \ == 3.\n\n   c. test_qa_history_config_loads(tmp_path):\n      Create a config\
      \ yaml with:\n        slack.conversation_history.enabled = false\n        slack.conversation_history.max_turns\
      \ = 5\n      Create SlackNotifier from that config.\n      Assert notifier._qa_history_enabled\
      \ is False.\n      Assert notifier._qa_history_max_turns == 5.\n\n   d. test_qa_history_config_defaults_when_absent(tmp_path):\n\
      \      Create a config yaml WITHOUT a conversation_history key.\n      Assert\
      \ notifier._qa_history_max_turns == 3 (default).\n      Assert notifier._qa_history_enabled\
      \ is True (default).\n\n   e. test_answer_question_records_exchange(tmp_path,\
      \ monkeypatch):\n      Create notifier with _make_notifier(tmp_path).\n    \
      \  Monkey-patch notifier._gather_pipeline_state to return {}.\n      Monkey-patch\
      \ notifier._format_state_context to return \"state: idle\".\n      Monkey-patch\
      \ notifier._call_claude_print to return \"Pipeline is idle.\".\n      Monkey-patch\
      \ notifier.send_status to capture calls.\n      Call notifier.answer_question(\"\
      What is the status?\").\n      Assert len(notifier._qa_history) == 1.\n    \
      \  Assert notifier._qa_history[0] == (\"What is the status?\", \"Pipeline is\
      \ idle.\").\n\n   f. test_answer_question_injects_history(tmp_path, monkeypatch):\n\
      \      Create notifier with _make_notifier(tmp_path).\n      Pre-seed: notifier._qa_history\
      \ = [(\"Prior Q\", \"Prior A\")].\n      Monkey-patch notifier._gather_pipeline_state\
      \ to return {}.\n      Monkey-patch notifier._format_state_context to return\
      \ \"state: idle\".\n      Capture the prompt passed to _call_claude_print (use\
      \ monkeypatch).\n      Monkey-patch _call_claude_print to record its argument\
      \ and return \"Answer\".\n      Monkey-patch send_status to no-op.\n      Call\
      \ notifier.answer_question(\"Follow-up question\").\n      Assert \"Prior Q\"\
      \ in the captured prompt.\n      Assert \"Prior A\" in the captured prompt.\n\
      \      Assert \"Prior conversation:\" in the captured prompt.\n\n   g. test_answer_question_trims_history(tmp_path,\
      \ monkeypatch):\n      Create notifier with _make_notifier(tmp_path).\n    \
      \  Set notifier._qa_history_max_turns = 2.\n      Monkey-patch _gather_pipeline_state,\
      \ _format_state_context, send_status.\n      Monkey-patch _call_claude_print\
      \ to return \"Answer N\".\n      Call answer_question(\"Q1\"), answer_question(\"\
      Q2\"), answer_question(\"Q3\").\n      Assert len(notifier._qa_history) == 2.\n\
      \      Assert notifier._qa_history[0][0] == \"Q2\".\n      Assert notifier._qa_history[1][0]\
      \ == \"Q3\".\n\n   h. test_answer_question_history_disabled(tmp_path, monkeypatch):\n\
      \      Create notifier with conversation_history.enabled = false in config.\n\
      \      Seed notifier._qa_history with one entry.\n      Monkey-patch _gather_pipeline_state,\
      \ _format_state_context, send_status.\n      Capture prompt via monkeypatched\
      \ _call_claude_print.\n      Call answer_question(\"What is running?\").\n \
      \     Assert \"Prior conversation:\" NOT in the captured prompt.\n      Assert\
      \ len(notifier._qa_history) == 1 (no new entry added, disabled).\n\n   i. test_answer_question_history_max_turns_zero(tmp_path,\
      \ monkeypatch):\n      Create notifier, set notifier._qa_history_max_turns =\
      \ 0.\n      Seed notifier._qa_history with one entry.\n      Monkey-patch dependencies\
      \ as above.\n      Call answer_question(\"Test\").\n      Assert \"Prior conversation:\"\
      \ NOT in the captured prompt.\n      Assert len(notifier._qa_history) == 1 (no\
      \ new entry added).\n\n   j. test_question_answer_prompt_has_history_placeholder:\n\
      \      Load the module.\n      Assert '{history_context}' in mod.QUESTION_ANSWER_PROMPT.\n\
      \n4. Run tests:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest tests/test_slack_notifier.py\
      \ -v\n   Fix any failures.\n\nFiles: tests/test_slack_notifier.py\n"
- id: phase-4
  name: Phase 4 - Verification
  status: pending
  tasks:
  - id: '4.1'
    name: Final verification - syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '3.1'
    description: "Run verification checks to confirm the conversation history feature\
      \ is\ncorrect and all tests pass.\n\nSteps:\n1. Check Python syntax for both\
      \ scripts:\n   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run the full test suite:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/ 2>/dev/null || echo 'No test suite configured'\n\n3. Verify the new\
      \ constant and fields exist:\n   python3 -c \"\n   import importlib.util\n \
      \  spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   assert hasattr(mod, 'QA_HISTORY_DEFAULT_MAX_TURNS'), 'Missing constant'\n\
      \   assert mod.QA_HISTORY_DEFAULT_MAX_TURNS == 3\n   n = mod.SlackNotifier('/nonexistent')\n\
      \   assert hasattr(n, '_qa_history')\n   assert hasattr(n, '_qa_history_enabled')\n\
      \   assert hasattr(n, '_qa_history_max_turns')\n   assert n._qa_history_max_turns\
      \ == 3\n   print('All constant and init fields verified OK')\n   \"\n\n4. Verify\
      \ history placeholder is in QUESTION_ANSWER_PROMPT:\n   python3 -c \"\n   import\
      \ importlib.util\n   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   assert '{history_context}' in mod.QUESTION_ANSWER_PROMPT\n   assert '{state_context}'\
      \ in mod.QUESTION_ANSWER_PROMPT\n   assert '{question}' in mod.QUESTION_ANSWER_PROMPT\n\
      \   print('QUESTION_ANSWER_PROMPT placeholders verified OK')\n   \"\n\n5. Verify\
      \ the config template has the new block:\n   python3 -c \"\n   import yaml\n\
      \   with open('.claude/slack.local.yaml.template') as f:\n       config = yaml.safe_load(f)\n\
      \   assert 'conversation_history' in config['slack']\n   assert config['slack']['conversation_history']['max_turns']\
      \ == 3\n   print('Config template conversation_history block verified')\n  \
      \ \"\n\n6. Run orchestrator dry-run to confirm no startup errors:\n   python3\
      \ scripts/plan-orchestrator.py --plan .claude/plans/sample-plan.yaml --dry-run\n\
      \nIf any check fails, report the specific failure with details.\n\nFiles: scripts/plan-orchestrator.py,\
      \ scripts/auto-pipeline.py,\n       .claude/slack.local.yaml.template, tests/test_slack_notifier.py\n"
