meta:
  name: Fix Pipeline Agent Commits Unrelated Working-Tree Changes
  description: >
    Add git stash/pop around sequential task execution so sub-agents only see
    a clean working tree plus their own changes. This prevents agents from
    accidentally committing unrelated concurrent edits. Two new helper
    functions (git_stash_working_changes, git_stash_pop) and integration into
    the sequential execution loop in plan-orchestrator.py.
  plan_doc: docs/plans/2026-02-17-7-pipeline-agent-commits-unrelated-working-tree-changes-design.md
  created: '2026-02-17'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
      - coder
    validators:
      - issue-verifier
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Implementation
  status: pending
  tasks:
  - id: '1.1'
    name: Add git stash helper functions
    agent: coder
    status: pending
    description: >
      Add two new helper functions to scripts/plan-orchestrator.py for git stash
      management. Place them near the existing git-related helpers (around the
      save_plan function at line ~1423).

      Reference: docs/plans/2026-02-17-7-pipeline-agent-commits-unrelated-working-tree-changes-design.md

      Add a constant near the top of the file (with other constants):
        ORCHESTRATOR_STASH_MESSAGE = "orchestrator-auto-stash"

      Function 1: git_stash_working_changes() -> bool
        - First check if there are any uncommitted changes by running:
          git diff --quiet && git diff --cached --quiet && git ls-files --others --exclude-standard
        - If the tree is clean (both diffs exit 0 and no untracked files), return False
        - Otherwise run: git stash push --include-untracked -m ORCHESTRATOR_STASH_MESSAGE
        - Check exit code. If success, print "[Stashed working-tree changes before task]"
          and return True
        - If stash command fails, print a warning and return False
        - Use subprocess.run with capture_output=True for all git commands

      Function 2: git_stash_pop() -> bool
        - Run: git stash pop
        - If exit code 0, print "[Restored stashed working-tree changes]" and return True
        - If exit code non-zero, print a warning:
          "[WARNING] git stash pop failed - stash preserved for manual resolution"
          Also print the stderr from the failed command for debugging
        - Return False on failure
        - Use subprocess.run with capture_output=True

      Files: scripts/plan-orchestrator.py
  - id: '1.2'
    name: Integrate stash/pop into sequential execution loop
    agent: coder
    status: pending
    depends_on:
      - '1.1'
    description: >
      Modify the sequential execution path in execute_plan() within
      scripts/plan-orchestrator.py to wrap each task with stash/pop calls.

      Reference: docs/plans/2026-02-17-7-pipeline-agent-commits-unrelated-working-tree-changes-design.md

      In the sequential execution block (around line 4490, after "Mark as
      in progress" and the save_plan call, before "Build and execute prompt"):

      1. Add stash call BEFORE the prompt build (around line 4500):
         stash_created = False
         if not dry_run:
             stash_created = git_stash_working_changes()

      2. Add pop call AFTER the task result processing is complete. This must
         happen regardless of task success or failure. Use a try/finally pattern:

         Wrap the prompt build + run_claude_task + result processing in a
         try/finally block where the finally clause does:
           if stash_created:
               git_stash_pop()

         The try block should start just after the stash call and the finally
         block should be placed after all result processing (after the
         save_plan call for task completion/failure, around line 4620+).

      3. Make sure the stash pop happens even if the task raises an exception.

      4. Do NOT add stash/pop to the parallel execution path (worktree-based) -
         that path already provides isolation.

      Files: scripts/plan-orchestrator.py

- id: phase-2
  name: Phase 2 - Unit Tests
  status: pending
  tasks:
  - id: '2.1'
    name: Add unit tests for stash helpers
    agent: coder
    status: pending
    depends_on:
      - '1.2'
    description: >
      Add unit tests for the git stash helper functions in
      tests/test_plan_orchestrator.py.

      Reference: docs/plans/2026-02-17-7-pipeline-agent-commits-unrelated-working-tree-changes-design.md

      First, import the new functions from the module (the module is already
      imported via importlib at the top of the file as 'mod'):
        git_stash_working_changes = mod.git_stash_working_changes
        git_stash_pop = mod.git_stash_pop
        ORCHESTRATOR_STASH_MESSAGE = mod.ORCHESTRATOR_STASH_MESSAGE

      Add these test cases:

      1. test_git_stash_working_changes_clean_tree:
         - Mock subprocess.run to simulate a clean working tree (git diff --quiet
           exits 0, no untracked files)
         - Assert function returns False
         - Assert git stash push was NOT called

      2. test_git_stash_working_changes_dirty_tree:
         - Mock subprocess.run to simulate a dirty tree (git diff --quiet exits
           non-zero)
         - Assert function returns True
         - Assert git stash push was called with correct arguments including
           --include-untracked and the stash message

      3. test_git_stash_working_changes_stash_fails:
         - Mock subprocess.run so the dirty check returns dirty but the stash
           push command fails
         - Assert function returns False

      4. test_git_stash_pop_success:
         - Mock subprocess.run to simulate successful git stash pop
         - Assert function returns True

      5. test_git_stash_pop_conflict:
         - Mock subprocess.run to simulate git stash pop failure (exit code 1)
         - Assert function returns False

      Use unittest.mock.patch to mock subprocess.run. Match on the git command
      arguments to return appropriate mock results for different calls.

      After writing the tests, run them:
        ~/.pyenv/versions/3.11.*/bin/python -m pytest tests/test_plan_orchestrator.py -v

      Fix any failures before completing.

      Files: tests/test_plan_orchestrator.py

- id: phase-3
  name: Phase 3 - Verification
  status: pending
  tasks:
  - id: '3.1'
    name: Verify syntax and run tests
    agent: code-reviewer
    status: pending
    depends_on:
      - '2.1'
    description: >
      Verify the implementation compiles and tests pass.

      Steps:
      1. Check Python syntax for both main scripts:
         python3 -c "import py_compile; py_compile.compile('scripts/auto-pipeline.py', doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

      2. Run all unit tests:
         python3 -m pytest tests/ 2>/dev/null || echo 'No test suite configured'

      3. Verify the new constant exists:
         grep -c "ORCHESTRATOR_STASH_MESSAGE" scripts/plan-orchestrator.py
         (should return 2 or more - definition + usage)

      4. Verify the new functions exist:
         grep -c "def git_stash_working_changes" scripts/plan-orchestrator.py
         grep -c "def git_stash_pop" scripts/plan-orchestrator.py
         (each should return 1)

      5. Verify stash integration in the sequential path:
         grep -c "git_stash_working_changes" scripts/plan-orchestrator.py
         (should return 2+ - definition + call site)
         grep -c "git_stash_pop" scripts/plan-orchestrator.py
         (should return 2+ - definition + call site)

      6. Run orchestrator dry-run to confirm no startup errors:
         python3 scripts/plan-orchestrator.py --plan .claude/plans/sample-plan.yaml --dry-run

      If any check fails, report the failure details.

      Files: scripts/plan-orchestrator.py, tests/test_plan_orchestrator.py
