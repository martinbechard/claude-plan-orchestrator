meta:
  name: Announce Completed Items in Type-Specific Slack Channels (features/defects)
  description: When _archive_and_report() in auto-pipeline.py successfully archives
    a completed item, send an additional announcement to the type-specific Slack channel
    (orchestrator-features for features, orchestrator-defects for defects) alongside
    the existing orchestrator-notifications message. Adds get_type_channel_id() to
    SlackNotifier and wires the cross-post into _archive_and_report().
  plan_doc: docs/plans/2026-02-18-1-announce-completed-items-in-their-type-specific-slack-channels-featuresdefects-design.md
  created: '2026-02-18'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Implementation
  status: completed
  tasks:
  - id: '1.1'
    name: Add get_type_channel_id() to SlackNotifier in plan-orchestrator.py
    agent: coder
    status: completed
    description: "Add a new public method `get_type_channel_id(item_type)` to the\n\
      `SlackNotifier` class in `scripts/plan-orchestrator.py`.\n\nReference: docs/plans/2026-02-18-1-announce-completed-items-in-their-type-specific-slack-channels-featuresdefects-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the method\n   `_get_notifications_channel_id()`\
      \ (around line 2990). Note its\n   structure: it builds a channel name from\
      \ the prefix, calls\n   `_discover_channels()`, and does a dict lookup with\
      \ a fallback.\n\n2. Immediately AFTER `_get_notifications_channel_id()` and\
      \ BEFORE\n   `send_status()`, insert the new method:\n\n     def get_type_channel_id(self,\
      \ item_type: str) -> str:\n         \"\"\"Return the channel ID for the type-specific\
      \ channel.\n\n         Maps item_type ('feature' or 'defect') to the corresponding\n\
      \         Slack channel (e.g. orchestrator-features or\n         orchestrator-defects)\
      \ using the existing _discover_channels()\n         infrastructure.\n\n    \
      \     Returns empty string if the channel is not found or Slack\n         is\
      \ disabled.\n         \"\"\"\n         suffix_map = {\"feature\": \"features\"\
      , \"defect\": \"defects\"}\n         suffix = suffix_map.get(item_type, \"\"\
      )\n         if not suffix:\n             return \"\"\n         channel_name\
      \ = f\"{self._channel_prefix}{suffix}\"\n         channels = self._discover_channels()\n\
      \         return channels.get(channel_name, \"\")\n\n3. Verify syntax:\n   python3\
      \ -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n4. Verify the method is callable:\n\
      \   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   notifier = mod.SlackNotifier()\n   assert\
      \ callable(notifier.get_type_channel_id), 'Method not found'\n   print('get_type_channel_id\
      \ verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T17:01:50.885902'
    model_used: sonnet
    completed_at: '2026-02-18T17:03:27.068006'
    result_message: Added get_type_channel_id() to SlackNotifier in plan-orchestrator.py,
      placed between _get_notifications_channel_id() and send_status(). Syntax and
      callable verification both pass.
  - id: '1.2'
    name: Cross-post completion announcement in _archive_and_report()
    agent: coder
    status: completed
    depends_on:
    - '1.1'
    description: "Wire the cross-post into `_archive_and_report()` in\n`scripts/auto-pipeline.py`\
      \ so that a successful archive sends an\nadditional announcement to the type-specific\
      \ Slack channel.\n\nReference: docs/plans/2026-02-18-1-announce-completed-items-in-their-type-specific-slack-channels-featuresdefects-design.md\n\
      \nSteps:\n1. Read scripts/auto-pipeline.py. Find `_archive_and_report()` (around\n\
      \   line 1722). Locate the success branch â€” the block that calls:\n     log(f\"\
      Item complete: {item.display_name} ({minutes}m {seconds}s)\")\n     slack.send_status(\n\
      \         f\"*Pipeline: completed* {item.display_name}\\n\"\n         f\"Duration:\
      \ {minutes}m {seconds}s\",\n         level=\"success\"\n     )\n     _log_summary(\"\
      INFO\", \"COMPLETED\", item.slug, ...)\n     return True\n\n2. After the existing\
      \ `slack.send_status(...)` call (and BEFORE\n   `_log_summary(...)` and `return\
      \ True`), insert:\n\n     # Cross-post to type-specific channel (orchestrator-features\
      \ or orchestrator-defects)\n     type_channel_id = slack.get_type_channel_id(item.item_type)\n\
      \     if type_channel_id:\n         slack.send_status(\n             f\"*Completed:*\
      \ {item.display_name}\\n\"\n             f\"Duration: {minutes}m {seconds}s\"\
      ,\n             level=\"success\",\n             channel_id=type_channel_id,\n\
      \         )\n\n3. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); print('syntax OK')\"\n\n4. Verify _archive_and_report is still\
      \ importable:\n   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('ap',\
      \ 'scripts/auto-pipeline.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   assert callable(mod._archive_and_report),\
      \ '_archive_and_report not found'\n   print('_archive_and_report verified OK')\n\
      \   \"\n\nFiles: scripts/auto-pipeline.py\n"
    attempts: 1
    last_attempt: '2026-02-18T17:03:29.621037'
    model_used: sonnet
    completed_at: '2026-02-18T17:05:53.721331'
    result_message: 'Inserted cross-post block in _archive_and_report() success branch
      (auto-pipeline.py:1752-1758): calls slack.get_type_channel_id(item.item_type)
      and, if a channel ID is found, sends an additional send_status() to that channel.
      Syntax and importability verified.'
- id: phase-2
  name: Phase 2 - Unit Tests
  status: pending
  tasks:
  - id: '2.1'
    name: Add unit tests for get_type_channel_id()
    agent: coder
    status: pending
    depends_on:
    - '1.2'
    description: "Add unit tests for `SlackNotifier.get_type_channel_id()` to\n`tests/test_plan_orchestrator.py`.\n\
      \nReference: docs/plans/2026-02-18-1-announce-completed-items-in-their-type-specific-slack-channels-featuresdefects-design.md\n\
      \nSteps:\n1. Read tests/test_plan_orchestrator.py to understand the existing\
      \ test\n   patterns. Note that SlackNotifier is imported from the module loaded\n\
      \   via importlib. The existing tests use `SlackNotifier()` (no args)\n   which\
      \ creates a disabled notifier.\n\n2. Add the following tests after the existing\
      \ tests:\n\n   a. test_get_type_channel_id_feature_returns_features_channel():\n\
      \      - Create a SlackNotifier instance: notifier = SlackNotifier()\n     \
      \ - Set notifier._channel_prefix = \"orchestrator-\"\n      - Set notifier._discovered_channels\
      \ = {\n            \"orchestrator-features\": \"C_FEATURES_ID\",\n         \
      \   \"orchestrator-defects\": \"C_DEFECTS_ID\",\n            \"orchestrator-notifications\"\
      : \"C_NOTIFY_ID\",\n        }\n      - Set notifier._channels_discovered_at\
      \ = float(\"inf\")  # prevent re-discovery\n      - Call result = notifier.get_type_channel_id(\"\
      feature\")\n      - Assert result == \"C_FEATURES_ID\"\n\n   b. test_get_type_channel_id_defect_returns_defects_channel():\n\
      \      - Same setup as above.\n      - Call result = notifier.get_type_channel_id(\"\
      defect\")\n      - Assert result == \"C_DEFECTS_ID\"\n\n   c. test_get_type_channel_id_unknown_type_returns_empty():\n\
      \      - Create a SlackNotifier instance.\n      - Call result = notifier.get_type_channel_id(\"\
      unknown\")\n      - Assert result == \"\"\n\n   d. test_get_type_channel_id_channel_not_in_discovered_returns_empty():\n\
      \      - Create a SlackNotifier instance.\n      - Set notifier._channel_prefix\
      \ = \"orchestrator-\"\n      - Set notifier._discovered_channels = {}  # no\
      \ channels discovered\n      - Set notifier._channels_discovered_at = float(\"\
      inf\")\n      - Call result = notifier.get_type_channel_id(\"feature\")\n  \
      \    - Assert result == \"\"\n\n   e. test_get_type_channel_id_custom_prefix():\n\
      \      - Create a SlackNotifier instance.\n      - Set notifier._channel_prefix\
      \ = \"myteam-\"\n      - Set notifier._discovered_channels = {\n           \
      \ \"myteam-features\": \"C_CUSTOM_FEATURES\",\n        }\n      - Set notifier._channels_discovered_at\
      \ = float(\"inf\")\n      - Call result = notifier.get_type_channel_id(\"feature\"\
      )\n      - Assert result == \"C_CUSTOM_FEATURES\"\n\n3. Run the tests:\n   ~/.pyenv/versions/3.11.*/bin/python\
      \ -m pytest tests/test_plan_orchestrator.py -v\n   Fix any failures before marking\
      \ this task complete.\n\nFiles: tests/test_plan_orchestrator.py\n"
- id: phase-3
  name: Phase 3 - Verification
  status: pending
  tasks:
  - id: '3.1'
    name: Final verification - syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '2.1'
    description: "Run all verification checks to confirm the feature is correctly\n\
      implemented and all tests pass.\n\nSteps:\n1. Check Python syntax for both scripts:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run the full test suite:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/ 2>/dev/null || echo 'No test suite configured'\n\n3. Verify get_type_channel_id()\
      \ method exists and maps correctly:\n   python3 -c \"\n   import importlib.util\n\
      \   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   notifier = mod.SlackNotifier()\n   notifier._channel_prefix = 'orchestrator-'\n\
      \   notifier._discovered_channels = {\n       'orchestrator-features': 'C_F',\n\
      \       'orchestrator-defects': 'C_D',\n   }\n   notifier._channels_discovered_at\
      \ = float('inf')\n   assert notifier.get_type_channel_id('feature') == 'C_F',\
      \ 'feature channel mismatch'\n   assert notifier.get_type_channel_id('defect')\
      \ == 'C_D', 'defect channel mismatch'\n   assert notifier.get_type_channel_id('unknown')\
      \ == '', 'unknown should return empty'\n   print('get_type_channel_id verified\
      \ OK')\n   \"\n\n4. Verify _archive_and_report calls get_type_channel_id:\n\
      \   python3 -c \"\n   import importlib.util, inspect\n   spec = importlib.util.spec_from_file_location('ap',\
      \ 'scripts/auto-pipeline.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   src = inspect.getsource(mod._archive_and_report)\n\
      \   assert 'get_type_channel_id' in src, 'Cross-post not found in _archive_and_report'\n\
      \   print('Cross-post wiring verified OK')\n   \"\n\n5. Run orchestrator dry-run\
      \ to confirm no startup errors:\n   python3 scripts/plan-orchestrator.py --plan\
      \ .claude/plans/sample-plan.yaml --dry-run\n\nIf any check fails, report the\
      \ specific failure with details.\n\nFiles: scripts/auto-pipeline.py, scripts/plan-orchestrator.py,\
      \ tests/test_plan_orchestrator.py\n"
