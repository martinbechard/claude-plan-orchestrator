meta:
  name: UX Designer Opus/Sonnet Loop with Slack Suspension
  description: Two-part enhancement - (1) ux-designer becomes Opus orchestrator invoking
    Sonnet subagent for design generation with Q&A loop, (2) Slack-based question
    suspension allows the pipeline to pause items while waiting for human answers.
  plan_doc: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md
  created: '2026-02-18'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Part 1 Documentation and Agent Definitions
  status: completed
  tasks:
  - id: '1.1'
    name: Create ux-implementer agent definition
    agent: coder
    status: completed
    description: "Create the Sonnet-based ux-implementer agent that produces design\
      \ documents\nfrom a design brief provided by the Opus ux-designer orchestrator.\n\
      \nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read .claude/agents/ux-designer.md for format reference (YAML frontmatter\n\
      \   + markdown body).\n2. Create .claude/agents/ux-implementer.md with:\n\n\
      \   Frontmatter:\n   - name: ux-implementer\n   - description: \"Sonnet-based\
      \ design implementer. Receives a design brief\n     from the Opus ux-designer\
      \ orchestrator and produces detailed UX design\n     documents. Returns STATUS:\
      \ COMPLETE with the design or STATUS: QUESTION\n     when clarification is needed.\
      \ Stateless -- all context must be provided\n     in each invocation.\"\n  \
      \ - tools: [Read, Grep, Glob]\n   - model: sonnet\n\n   Body:\n\n   ## Role\n\
      \   You are a UX design implementer working under the direction of an Opus\n\
      \   orchestrator. You receive a design brief with requirements and optional\n\
      \   Q&A history from prior rounds. Your job is to produce a complete UX\n  \
      \ design document OR return a structured question if you need clarification.\n\
      \n   ## Output Protocol\n   Your response MUST begin with exactly one of these\
      \ status lines:\n\n   STATUS: COMPLETE\n   ---\n   <full design document following\
      \ the structure below>\n\n   STATUS: QUESTION\n   QUESTION: <one specific, answerable\
      \ question>\n   CONTEXT: <why this information is needed for the design>\n\n\
      \   ## When to Ask Questions\n   Only ask a question when:\n   - The design\
      \ brief is ambiguous about a critical layout or interaction choice\n   - Two\
      \ valid design approaches exist and the choice significantly affects UX\n  \
      \ - A requirement contradicts an existing pattern in the codebase\n\n   Do NOT\
      \ ask questions about:\n   - Minor stylistic choices you can resolve by following\
      \ existing patterns\n   - Implementation details (you produce designs, not code)\n\
      \   - Things already answered in the Q&A history\n\n   ## Design Document Structure\
      \ (for STATUS: COMPLETE)\n   Include all sections from the standard ux-designer\
      \ output:\n   - 5 Whys Analysis\n   - User Flow\n   - Wireframes (ASCII)\n \
      \  - Component Specs\n   - State Diagrams\n   - Responsive Design\n   - Accessibility\n\
      \   - Design System Integration\n\n   If the orchestrator documented any assumptions\
      \ in the Q&A history, include\n   an \"## Assumptions\" section listing them\
      \ so the judge and implementer can\n   see what was assumed.\n\n   ## Constraints\n\
      \   - You are READ-ONLY. Never use Write, Edit, or Bash tools.\n   - Only use\
      \ Read, Grep, and Glob to inspect the codebase.\n   - Always start your response\
      \ with STATUS: COMPLETE or STATUS: QUESTION.\n   - If you have multiple questions,\
      \ pick the single most important one.\n   - Base design decisions on evidence\
      \ from the existing UI codebase.\n\n3. Git commit:\n   git add .claude/agents/ux-implementer.md\n\
      \   git commit -m \"feat: add ux-implementer Sonnet agent for design loop\"\n\
      \nFiles: .claude/agents/ux-implementer.md\n"
    attempts: 1
    last_attempt: '2026-02-18T20:43:53.053534'
    model_used: sonnet
    completed_at: '2026-02-18T20:45:37.522841'
    result_message: 'Created .claude/agents/ux-implementer.md — Sonnet-based design
      implementer with STATUS: COMPLETE/QUESTION output protocol, read-only constraints,
      and full design document structure guidance'
  - id: '1.2'
    name: Rewrite ux-designer as Opus orchestrator with loop logic
    agent: coder
    status: completed
    depends_on:
    - '1.1'
    description: "Rewrite the ux-designer agent to be an Opus-based orchestrator that\
      \ produces\na design brief, invokes the ux-implementer Sonnet agent in a loop,\
      \ and handles\nQ&A rounds.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read .claude/agents/ux-designer.md (current version).\n2. Read\
      \ .claude/agents/ux-implementer.md (created in task 1.1).\n3. Rewrite .claude/agents/ux-designer.md\
      \ with:\n\n   Frontmatter:\n   - name: ux-designer\n   - description: \"UX design\
      \ orchestrator (Opus). Produces a design brief, then\n     invokes the ux-implementer\
      \ (Sonnet) agent in a loop. Handles Q&A rounds\n     by answering Sonnet's questions\
      \ using its own reasoning, re-injecting\n     full Q&A history on each round.\
      \ Capped at 3 rounds. Read-only for codebase,\n     but writes the final design\
      \ document.\"\n   - tools: [Read, Grep, Glob, Bash, Write]\n   - model: opus\n\
      \n   Body:\n\n   ## Role\n   You are a UX design orchestrator. You analyze requirements,\
      \ produce a\n   design brief, then delegate the detailed design work to the\
      \ ux-implementer\n   agent (Sonnet) via Claude CLI. You handle clarification\
      \ questions by\n   answering them yourself or, if you truly cannot answer, by\
      \ reporting the\n   question to the orchestrator for human escalation.\n\n \
      \  ## Workflow\n\n   ### Step 1: Analyze and Brief\n   1. Read the task description\
      \ and plan document thoroughly\n   2. Read existing UI components to understand\
      \ the design system\n   3. Perform the 5 Whys analysis (same as before)\n  \
      \ 4. Produce a structured design brief containing:\n      - Root need from 5\
      \ Whys\n      - Requirements extracted from the task\n      - Existing patterns\
      \ and components to reuse\n      - Constraints and edge cases\n\n   ### Step\
      \ 2: Invoke ux-implementer Loop\n   Run a loop (max 3 rounds) where you invoke\
      \ the ux-implementer Sonnet\n   agent via Claude CLI:\n\n   ```bash\n   claude\
      \ --print --model sonnet --output-format json \\\n     --dangerously-skip-permissions\
      \ \"<prompt>\"\n   ```\n\n   The prompt must include:\n   - The full design\
      \ brief from Step 1\n   - Any accumulated Q&A history (empty on round 1)\n \
      \  - Instructions to follow the ux-implementer protocol\n\n   ### Step 3: Handle\
      \ Response\n   Parse the first line of Sonnet's response:\n\n   - **STATUS:\
      \ COMPLETE** -- Extract the design document after the \"---\"\n     separator.\
      \ Write it to the output path. Done.\n\n   - **STATUS: QUESTION** -- Extract\
      \ the question and context. Decide:\n     a) If you can answer confidently from\
      \ requirements + codebase: answer\n        it, add to Q&A history, loop back\
      \ to Step 2.\n     b) If you cannot answer (truly ambiguous, needs human input):\
      \ write\n        task-status.json with status \"suspended\" and include the\
      \ question.\n        (Part 2 will handle the Slack posting.)\n\n   ### Step\
      \ 4: Handle Max Rounds\n   If 3 rounds pass without STATUS: COMPLETE, take the\
      \ best partial design\n   from the last round, add an \"## Open Questions\"\
      \ section listing unresolved\n   questions, and write it as the output. Report\
      \ as completed with a warning\n   in the status message.\n\n   ## Q&A History\
      \ Format\n   Prepend this to the design brief on rounds 2+:\n\n   ## Prior Design\
      \ Q&A\n   Q1: <question from round 1>\n   A1: <your answer>\n   Q2: <question\
      \ from round 2>\n   A2: <your answer>\n\n   ## Assumptions\n   Document every\
      \ assumption you made while answering questions:\n   - \"Assumed grid layout\
      \ based on existing dashboard patterns\"\n   - \"Assumed mobile-first based\
      \ on responsive breakpoints in globals.css\"\n\n   ## Evaluation Criteria (same\
      \ as before)\n   - Clarity (0-10)\n   - Mobile UX (0-10)\n   - Accessibility\
      \ (0-10)\n   - Consistency (0-10)\n   - Completeness (0-10)\n\n   ## Constraints\n\
      \   - Use Claude CLI (not the Task tool) to invoke ux-implementer\n   - Re-inject\
      \ full Q&A history on every Sonnet call (stateless)\n   - Cap at 3 rounds maximum\n\
      \   - Document all assumptions made while answering questions\n   - If suspending:\
      \ write task-status.json with status \"suspended\"\n\n   ## Output Protocol\n\
      \   Write status to .claude/plans/task-status.json:\n   - status: \"completed\"\
      \ with design document written\n   - status: \"suspended\" with question details\
      \ (for human escalation)\n   - status: \"failed\" if unable to produce any design\n\
      \n4. Git commit:\n   git add .claude/agents/ux-designer.md\n   git commit -m\
      \ \"feat: rewrite ux-designer as Opus orchestrator with Sonnet loop\"\n\nFiles:\
      \ .claude/agents/ux-designer.md\n"
    attempts: 2
    last_attempt: '2026-02-18T20:48:44.143479'
    model_used: sonnet
    validation_findings: '[PASS] Build check: Python compilation of `scripts/auto-pipeline.py`
      and `scripts/plan-orchestrator.py` succeeds with no errors\n- [PASS] Frontmatter
      name: `ux-designer` matches requirement — `.claude/agents/ux-designer.md:2`\n-
      [PASS] Frontmatter description: Matches required text verbatim — `.claude/agents/ux-designer.md:3-7`\n-
      [PASS] Frontmatter tools: `[Read, Grep, Glob, Bash, Write]` matches requirement
      — `.claude/agents/ux-designer.md:8-13`\n- [PASS] Frontmatter model: `opus` matches
      requirement — `.claude/agents/ux-designer.md:14`\n- [PASS] Role section: Matches
      required orchestrator description — `.claude/agents/ux-designer.md:19-25`\n-
      [PASS] Step 1 (Analyze and Brief): Includes 5 Whys analysis and structured design
      brief — `.claude/agents/ux-designer.md:29-44`\n- [PASS] Step 2 (ux-implementer
      Loop): Claude CLI command with max 3 rounds — `.claude/agents/ux-designer.md:46-59`\n-
      [PASS] Step 3 (Handle Response): STATUS: COMPLETE and STATUS: QUESTION handling
      with suspension — `.claude/agents/ux-designer.md:61-73`\n- [PASS] Step 4 (Handle
      Max Rounds): Best partial design with Open Questions section — `.claude/agents/ux-designer.md:75-80`\n-
      [PASS] Q&A History Format: Numbered Q/A prepended on rounds 2+ — `.claude/agents/ux-designer.md:82-92`\n-
      [PASS] Assumptions section: Documents assumptions made while answering — `.claude/agents/ux-designer.md:94-98`\n-
      [PASS] Evaluation Criteria: All 5 criteria present (Clarity, Mobile UX, Accessibility,
      Consistency, Completeness) — `.claude/agents/ux-designer.md:100-106`\n- [PASS]
      Constraints section: All 5 constraints present — `.claude/agents/ux-designer.md:108-114`\n-
      [PASS] Output Protocol: Includes completed/suspended/failed statuses with JSON
      examples — `.claude/agents/ux-designer.md:116-147`\n- [PASS] Git commit: `2d2d29b`
      with correct message `feat: rewrite ux-designer as Opus orchestrator with Sonnet
      loop`\n- [FAIL] Test regression: `tests/test_spec_verifier_ux_reviewer.py:102`
      — `test_ux_reviewer_distinct_from_ux_designer` asserts `ux_designer[\"model\"]
      == \"sonnet\"` but the task changed the model to `opus`. Test suite shows 1
      failed / 254 passed.\n\n**Evidence:**\n\n- Finding 17 (FAIL): Test output shows:\n  ```\n  FAILED
      tests/test_spec_verifier_ux_reviewer.py::test_ux_reviewer_distinct_from_ux_designer\n  AssertionError:
      ux-designer should use sonnet model, got opus\n  assert ''opus'' == ''sonnet''\n  ```\n  The
      test at line 102 expects `sonnet` but the task explicitly requires `model: opus`.
      The existing test should have been updated as part of the task per CLAUDE.md
      coding rules: \"ALWAYS fix existing regression tests.\""}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":484,"cache_read_input_tokens":48534,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":484},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"parent_tool_use_id":null,"session_id":"c7ae5bc1-35ca-4b64-8b73-c467786839a8","uuid":"4ad92912-1216-4c26-b7c4-958b7a8d97f1"}'
    validation_attempts: 1
    completed_at: '2026-02-18T20:49:40.309179'
    result_message: 'Fixed test regression: updated test_ux_reviewer_distinct_from_ux_designer
      to expect opus model for ux-designer (the agent was correctly rewritten as Opus
      orchestrator in the prior attempt). All 255 tests pass.'
- id: phase-2
  name: Phase 2 - Part 1 Implementation (plan-orchestrator changes)
  status: completed
  tasks:
  - id: '2.1'
    name: Add UX design loop constants and suspended task status handling
    agent: coder
    status: completed
    depends_on:
    - '1.2'
    description: "Add configuration constants for the UX design loop and handle the\
      \ new\n\"suspended\" task status in plan-orchestrator.py.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the config constants section\n\
      \   (around lines 41-55 where DEFAULT_BUILD_COMMAND etc. are defined).\n\n2.\
      \ After DEFAULT_E2E_COMMAND, add:\n\n   # UX design loop configuration\n   UX_DESIGN_MAX_ROUNDS\
      \ = 3\n\n3. Add SUSPENDED_DIR to the REQUIRED_DIRS list (around line 66):\n\n\
      \   SUSPENDED_DIR = \".claude/suspended\"\n\n   And add it to REQUIRED_DIRS:\n\
      \   \".claude/suspended\",\n\n4. Find the read_task_status() function (search\
      \ for \"def read_task_status\"\n   or where task-status.json is read and parsed).\
      \ Currently, the function\n   handles \"completed\", \"failed\", and \"skipped\"\
      \ statuses. Add handling for\n   \"suspended\":\n\n   When status == \"suspended\"\
      :\n   - Log: \"[SUSPENDED] Task {task_id} suspended: {message}\"\n   - Set task\
      \ status to \"suspended\" in the plan YAML\n   - Save the plan YAML\n   - Return\
      \ early (do not retry, do not mark as failed)\n\n   Search for where the orchestrator\
      \ processes task result statuses\n   (look for 'status == \"completed\"' or\
      \ 'status == \"failed\"' patterns\n   in the main execution loop). Add a branch\
      \ for \"suspended\" that:\n   - Prints a suspension notice\n   - Writes the\
      \ plan with the task marked \"suspended\"\n   - Returns from the current task\
      \ execution without error\n\n5. In find_next_task() (around line 1656), ensure\
      \ tasks with status\n   \"suspended\" are skipped (treated like \"completed\"\
      \ for sequencing but\n   the section remains \"in_progress\"). Add \"suspended\"\
      \ to any status\n   checks that currently skip \"completed\" and \"skipped\"\
      \ tasks.\n\n6. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n7. Git commit:\n   git add scripts/plan-orchestrator.py\n\
      \   git commit -m \"feat: add UX loop constants and suspended task status handling\"\
      \n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T20:49:43.009213'
    model_used: sonnet
    completed_at: '2026-02-18T20:55:05.794792'
    result_message: Added UX_DESIGN_MAX_ROUNDS=3 and SUSPENDED_DIR constants, added
      '.claude/suspended' to REQUIRED_DIRS, added suspended field to TaskResult dataclass,
      added 'suspended' status branch in run_claude_task() and main orchestrator loop,
      documented suspended skip behavior in find_next_task(). All 255 tests pass.
- id: phase-3
  name: Phase 3 - Part 2 Suspension Infrastructure
  status: in_progress
  tasks:
  - id: '3.1'
    name: Add suspension marker file management to plan-orchestrator
    agent: coder
    status: completed
    depends_on:
    - '2.1'
    description: "Add functions to plan-orchestrator.py for creating, reading, and\
      \ clearing\nsuspension marker files. These are used when a ux-designer task\
      \ writes\nstatus \"suspended\" and the pipeline needs to track the pending question.\n\
      \nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py.\n\n2. After the SUSPENDED_DIR\
      \ constant (added in task 2.1), add a constant:\n\n   SUSPENSION_TIMEOUT_MINUTES\
      \ = 1440  # 24 hours default\n\n3. After the parse_verification_blocks() function\
      \ (or nearby utility\n   functions), add three new functions:\n\n   a. create_suspension_marker(slug,\
      \ item_type, item_path, plan_path,\n      task_id, question, question_context)\
      \ -> str:\n      \"\"\"Create a suspension marker file for a work item.\n\n\
      \      Returns the path to the marker file.\n      \"\"\"\n      - Build a dict\
      \ with all args plus suspended_at (ISO timestamp),\n        timeout_minutes\
      \ (SUSPENSION_TIMEOUT_MINUTES), and empty fields\n        for slack_thread_ts,\
      \ slack_channel_id, answer\n      - Write to SUSPENDED_DIR/<slug>.json\n   \
      \   - Return the path\n\n   b. read_suspension_marker(slug) -> Optional[dict]:\n\
      \      \"\"\"Read a suspension marker file. Returns None if not found.\"\"\"\
      \n      - Read from SUSPENDED_DIR/<slug>.json\n      - Return parsed dict or\
      \ None\n\n   c. clear_suspension_marker(slug) -> bool:\n      \"\"\"Remove a\
      \ suspension marker file. Returns True if removed.\"\"\"\n      - Delete SUSPENDED_DIR/<slug>.json\n\
      \      - Return True if removed, False if not found\n\n   d. is_item_suspended(slug)\
      \ -> bool:\n      \"\"\"Check if an item has an active suspension marker.\"\"\
      \"\n      - Check if SUSPENDED_DIR/<slug>.json exists\n      - If it exists,\
      \ check if it has timed out (suspended_at + timeout_minutes)\n      - If timed\
      \ out, clear the marker and return False\n      - Otherwise return True\n\n\
      \   e. get_suspension_answer(slug) -> Optional[str]:\n      \"\"\"Get the human's\
      \ answer from a suspension marker, if available.\"\"\"\n      - Read the marker\
      \ file\n      - Return marker.get(\"answer\") if it's a non-empty string\n \
      \     - Return None otherwise\n\n4. Verify syntax:\n   python3 -c \"import py_compile;\
      \ py_compile.compile('scripts/plan-orchestrator.py', doraise=True); print('syntax\
      \ OK')\"\n\n5. Git commit:\n   git add scripts/plan-orchestrator.py\n   git\
      \ commit -m \"feat: add suspension marker file management functions\"\n\nFiles:\
      \ scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T20:55:08.180999'
    model_used: sonnet
    completed_at: '2026-02-18T20:57:38.282409'
    result_message: Added SUSPENSION_TIMEOUT_MINUTES constant and 5 suspension marker
      functions (create, read, clear, is_item_suspended, get_suspension_answer) to
      plan-orchestrator.py
  - id: '3.2'
    name: Add Slack question posting for suspended items
    agent: coder
    status: completed
    depends_on:
    - '3.1'
    description: "Add a method to SlackNotifier that posts a design question to the\n\
      appropriate Slack channel when a work item is suspended. The message\nincludes\
      \ the item slug and question text, and the thread_ts is stored\nback in the\
      \ suspension marker for reply correlation.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class\n\
      \   (around line 2891).\n\n2. After the send_question() method (around line\
      \ 3260), add a new method:\n\n   def post_suspension_question(\n       self,\n\
      \       slug: str,\n       item_type: str,\n       question: str,\n       question_context:\
      \ str,\n   ) -> Optional[str]:\n       \"\"\"Post a suspension question to the\
      \ type-specific Slack channel.\n\n       Posts a formatted message to the features\
      \ or defects channel with\n       the question details. Returns the message\
      \ thread_ts for reply\n       correlation, or None on failure.\n\n       Args:\n\
      \           slug: Work item slug (e.g., \"9-ux-feature\")\n           item_type:\
      \ \"feature\" or \"defect\"\n           question: The question text\n      \
      \     question_context: Why this information is needed\n       \"\"\"\n    \
      \   - Determine target channel using _get_channel_id_for_role()\n         with\
      \ the item_type (\"feature\" -> features channel, \"defect\" ->\n         defects\
      \ channel)\n       - Build a Block Kit message:\n         Header: \":question:\
      \ *Design Question for {slug}*\"\n         Section: \"*Question:* {question}\"\
      \n         Section: \"*Context:* {question_context}\"\n         Context: \"\
      _Reply in this thread to answer. The pipeline will\n         resume processing\
      \ automatically._\"\n       - Post the message using _post_message() and capture\
      \ the response\n       - Extract and return the message ts from the response\
      \ (this is\n         the thread_ts for reply correlation)\n       - Return None\
      \ on failure\n\n3. Add a method to check for threaded replies to a suspension\
      \ question:\n\n   def check_suspension_reply(\n       self,\n       channel_id:\
      \ str,\n       thread_ts: str,\n   ) -> Optional[str]:\n       \"\"\"Check for\
      \ a human reply in a Slack thread.\n\n       Uses conversations.replies API\
      \ to check if there are replies\n       to the suspension question message.\
      \ Returns the reply text\n       if found, None otherwise. Ignores bot messages.\n\
      \       \"\"\"\n       - Call Slack API: conversations.replies with channel,\
      \ ts=thread_ts,\n         limit=5\n       - Filter messages: skip the original\
      \ (ts == thread_ts), skip bot\n         messages (check for \"bot_id\" key)\n\
      \       - Return the text of the first human reply, or None if none found\n\n\
      4. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n5. Git commit:\n   git add scripts/plan-orchestrator.py\n\
      \   git commit -m \"feat: add Slack suspension question posting and reply checking\"\
      \n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T20:57:40.741075'
    model_used: sonnet
    completed_at: '2026-02-18T21:01:47.953992'
    result_message: Added SLACK_THREAD_REPLIES_LIMIT constant, _post_message_get_ts()
      private helper, post_suspension_question() for posting Block Kit questions to
      type-specific Slack channels, and check_suspension_reply() for polling conversations.replies
      for human thread responses
  - id: '3.3'
    name: Add suspension handling to auto-pipeline
    agent: coder
    status: completed
    depends_on:
    - '3.2'
    description: "Modify auto-pipeline.py to handle suspended work items: skip them\
      \ during\nnormal scanning, check for answers via Slack, and reinstate answered\
      \ items.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read scripts/auto-pipeline.py.\n\n2. Import the suspension functions\
      \ from plan-orchestrator. Near the top\n   where SlackNotifier is imported (around\
      \ line 48), also import:\n\n   is_item_suspended = _po_mod.is_item_suspended\n\
      \   read_suspension_marker = _po_mod.read_suspension_marker\n   get_suspension_answer\
      \ = _po_mod.get_suspension_answer\n   clear_suspension_marker = _po_mod.clear_suspension_marker\n\
      \   SUSPENDED_DIR = _po_mod.SUSPENDED_DIR\n\n3. Add SUSPENDED_DIR to the REQUIRED_DIRS\
      \ list in auto-pipeline.py\n   (around line 76). Add \".claude/suspended\" to\
      \ the list.\n\n4. In the scan_directory() function (around line 575), after\
      \ the\n   is_item_completed() check but before adding the item to the list,\n\
      \   add a suspension check:\n\n   if is_item_suspended(slug):\n       verbose_log(f\"\
      Skipping suspended item: {slug}\")\n       continue\n\n5. In the main_loop()\
      \ function (around line 2152), add a new phase\n   before the normal item scanning.\
      \ After the in-progress plan resumption\n   block and before the backlog scanning,\
      \ add:\n\n   # Check suspended items for answers\n   _check_suspended_items(slack)\n\
      \n6. Create a new function _check_suspended_items(slack: SlackNotifier):\n \
      \  \"\"\"Check all suspended items for Slack answers and reinstate them.\"\"\
      \"\n   - List all .json files in SUSPENDED_DIR\n   - For each file:\n     a.\
      \ Read the suspension marker\n     b. If it has a slack_thread_ts and slack_channel_id:\n\
      \        Call slack.check_suspension_reply(channel_id, thread_ts)\n     c. If\
      \ an answer is found:\n        - Write the answer into the marker file\n   \
      \     - Log the reinstatement\n        - Clear the suspension marker\n     \
      \   - The item will be picked up on the next scan cycle naturally\n     d. If\
      \ timed out (check suspended_at + timeout_minutes):\n        - Clear the marker\n\
      \        - Log timeout warning\n        - The item returns to normal processing\n\
      \n7. In the _process_item_inner() function, after the orchestrator\n   execution\
      \ (Phase 2), check if the plan has any suspended tasks.\n   If so, create a\
      \ suspension marker file and post the question to Slack:\n\n   After execute_plan()\
      \ returns True, check if any task in the plan\n   has status \"suspended\".\
      \ If so:\n   - Read the suspended task's status message for the question\n \
      \  - Call create_suspension_marker() with the relevant details\n   - Call slack.post_suspension_question()\
      \ and store the thread_ts\n     back in the marker file\n   - Log the suspension\n\
      \   - Return True (item is suspended, not failed)\n\n8. Verify syntax:\n   python3\
      \ -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py', doraise=True);\
      \ print('syntax OK')\"\n\n9. Git commit:\n   git add scripts/auto-pipeline.py\n\
      \   git commit -m \"feat: add suspension handling to auto-pipeline\"\n\nFiles:\
      \ scripts/auto-pipeline.py\n"
    attempts: 1
    last_attempt: '2026-02-18T21:01:50.677698'
    model_used: sonnet
    completed_at: '2026-02-18T21:10:29.958003'
    result_message: 'Added suspension handling to auto-pipeline.py: imported suspension
      functions, added SUSPENDED_DIR to REQUIRED_DIRS, scan_directory() skips suspended
      items, _check_suspended_items() polls for Slack answers each cycle, _process_item_inner()
      detects suspended plan tasks and posts questions to Slack via _handle_suspension().
      All 255 tests pass.'
  - id: '3.4'
    name: Wire suspension reply checking into Slack background poller
    agent: coder
    status: in_progress
    depends_on:
    - '3.3'
    description: "Extend the Slack background poller to periodically check for replies\n\
      to suspension questions, so answers are detected even between pipeline\nscan\
      \ cycles.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read scripts/plan-orchestrator.py. Find the _poll_loop function\n\
      \   inside start_background_polling() (around line 4158).\n\n2. Add a new method\
      \ to SlackNotifier:\n\n   def _check_all_suspensions(self) -> None:\n      \
      \ \"\"\"Check all suspended items for Slack thread replies.\n\n       Called\
      \ periodically by the background poller. For each suspension\n       marker\
      \ with a slack_thread_ts, checks for human replies. If found,\n       writes\
      \ the answer back to the marker file.\n       \"\"\"\n       - Import glob at\
      \ top of file if not already imported\n       - List all files in SUSPENDED_DIR\
      \ matching *.json\n       - For each file:\n         a. Read the marker JSON\n\
      \         b. Skip if no slack_thread_ts or slack_channel_id\n         c. Skip\
      \ if already has an \"answer\" field\n         d. Call self.check_suspension_reply(channel_id,\
      \ thread_ts)\n         e. If reply found:\n            - Write answer into the\
      \ marker dict\n            - Save the updated marker file\n            - Post\
      \ a confirmation to the same Slack channel:\n              \":white_check_mark:\
      \ Answer received for {slug}. Item will\n              resume on next pipeline\
      \ cycle.\"\n            - Log: \"[SLACK] Answer received for suspended item:\
      \ {slug}\"\n\n3. In the _poll_loop function (around line 4158), after the existing\n\
      \   poll_messages/handle call, add a call to _check_all_suspensions():\n\n \
      \  In the while loop body, after handling polled messages, add:\n   self._check_all_suspensions()\n\
      \n4. Verify syntax:\n   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n5. Git commit:\n   git add scripts/plan-orchestrator.py\n\
      \   git commit -m \"feat: wire suspension reply checking into Slack background\
      \ poller\"\n\nFiles: scripts/plan-orchestrator.py\n"
    attempts: 1
    last_attempt: '2026-02-18T21:10:32.484089'
- id: phase-4
  name: Phase 4 - Unit Tests
  status: pending
  tasks:
  - id: '4.1'
    name: Add unit tests for suspension marker functions
    agent: coder
    status: pending
    depends_on:
    - '3.1'
    description: "Add unit tests for the suspension marker file management functions\n\
      added in task 3.1.\n\nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read tests/test_plan_orchestrator.py for existing test patterns.\n\
      \n2. Add the following tests:\n\n   a. test_create_suspension_marker():\n  \
      \    - Use tmp_path fixture to create a temporary SUSPENDED_DIR\n      - Monkeypatch\
      \ SUSPENDED_DIR to use tmp_path\n      - Call create_suspension_marker() with\
      \ test data\n      - Assert the file exists at the expected path\n      - Read\
      \ the file and assert all fields are present\n      - Assert suspended_at is\
      \ a valid ISO timestamp\n      - Assert answer is empty/None\n\n   b. test_read_suspension_marker_exists():\n\
      \      - Create a marker file manually in tmp_path\n      - Monkeypatch SUSPENDED_DIR\n\
      \      - Call read_suspension_marker(\"test-slug\")\n      - Assert returns\
      \ the expected dict\n\n   c. test_read_suspension_marker_not_found():\n    \
      \  - Monkeypatch SUSPENDED_DIR to an empty tmp_path\n      - Call read_suspension_marker(\"\
      nonexistent\")\n      - Assert returns None\n\n   d. test_clear_suspension_marker():\n\
      \      - Create a marker file in tmp_path\n      - Monkeypatch SUSPENDED_DIR\n\
      \      - Call clear_suspension_marker(\"test-slug\")\n      - Assert returns\
      \ True\n      - Assert file no longer exists\n\n   e. test_is_item_suspended_active():\n\
      \      - Create a marker with recent suspended_at\n      - Monkeypatch SUSPENDED_DIR\n\
      \      - Assert is_item_suspended(\"test-slug\") returns True\n\n   f. test_is_item_suspended_timed_out():\n\
      \      - Create a marker with suspended_at far in the past (>24h ago)\n    \
      \  - Set timeout_minutes to 1\n      - Monkeypatch SUSPENDED_DIR\n      - Assert\
      \ is_item_suspended(\"test-slug\") returns False\n      - Assert the marker\
      \ file was cleaned up\n\n   g. test_get_suspension_answer_present():\n     \
      \ - Create a marker with answer field set\n      - Assert get_suspension_answer()\
      \ returns the answer\n\n   h. test_get_suspension_answer_absent():\n      -\
      \ Create a marker without answer field\n      - Assert get_suspension_answer()\
      \ returns None\n\n3. Run the tests:\n   ~/.pyenv/versions/3.11.*/bin/python\
      \ -m pytest tests/test_plan_orchestrator.py -v -k suspension\n   Fix any failures\
      \ before marking this task complete.\n\nFiles: tests/test_plan_orchestrator.py\n"
  - id: '4.2'
    name: Add unit tests for suspended task status handling
    agent: coder
    status: pending
    depends_on:
    - '2.1'
    - '4.1'
    description: "Add unit tests verifying that find_next_task() correctly skips suspended\n\
      tasks and that the task status handling works for the \"suspended\" status.\n\
      \nReference: docs/plans/2026-02-18-9-ux-designer-opus-sonnet-loop-with-slack-suspension-design.md\n\
      \nSteps:\n1. Read tests/test_plan_orchestrator.py for existing test patterns,\n\
      \   especially tests for find_next_task().\n\n2. Add the following tests:\n\n\
      \   a. test_find_next_task_skips_suspended():\n      - Create a plan dict with\
      \ two tasks: first is \"suspended\", second\n        is \"pending\"\n      -\
      \ Call find_next_task(plan)\n      - Assert it returns the second task (skips\
      \ suspended)\n\n   b. test_find_next_task_all_suspended():\n      - Create a\
      \ plan with all tasks \"suspended\"\n      - Call find_next_task(plan)\n   \
      \   - Assert returns None (no actionable tasks)\n\n   c. test_section_status_with_suspended_task():\n\
      \      - Create a section with one completed task and one suspended task\n \
      \     - Call update_section_status(section)\n      - Assert section status is\
      \ \"in_progress\" (not \"completed\" because\n        suspended task is not\
      \ done)\n\n3. Run the tests:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/test_plan_orchestrator.py -v -k suspended\n   Fix any failures before\
      \ marking this task complete.\n\nFiles: tests/test_plan_orchestrator.py\n"
- id: phase-5
  name: Phase 5 - Plugin Version Bump
  status: pending
  tasks:
  - id: '5.1'
    name: Bump plugin version and update release notes
    agent: coder
    status: pending
    depends_on:
    - '3.4'
    description: "Bump the plugin version in plugin.json and update RELEASE-NOTES.md\n\
      for the UX designer Opus/Sonnet loop feature.\n\nSteps:\n1. Read plugin.json.\
      \ Find the current version number.\n2. Bump the minor version (this is a new\
      \ feature).\n3. Read RELEASE-NOTES.md. Add a new entry at the top for the new\n\
      \   version with a summary:\n   - **Opus/Sonnet design loop**: UX designer agent\
      \ now runs as Opus\n     orchestrator invoking Sonnet subagent for design generation.\
      \ Handles\n     Q&A rounds automatically, capped at 3 rounds.\n   - **ux-implementer\
      \ agent**: New Sonnet-based agent that produces\n     design documents from\
      \ design briefs with structured STATUS protocol.\n   - **Slack-based question\
      \ suspension**: Work items can be suspended\n     when a design question requires\
      \ human input. Questions posted to\n     Slack; pipeline continues other work;\
      \ answers resume the item\n     automatically.\n   - **Suspension marker files**:\
      \ New .claude/suspended/ directory for\n     tracking suspended items with timeout\
      \ and Slack thread correlation.\n4. Git commit both files:\n   git add plugin.json\
      \ RELEASE-NOTES.md\n   git commit -m \"chore: bump version for ux-designer-opus-sonnet-loop\
      \ feature\"\n\nFiles: plugin.json, RELEASE-NOTES.md\n"
- id: phase-6
  name: Phase 6 - Final Verification
  status: pending
  tasks:
  - id: '6.1'
    name: Final verification - syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '4.1'
    - '4.2'
    - '5.1'
    description: "Run all verification checks to confirm the feature is correctly\n\
      implemented and all tests pass.\n\nSteps:\n1. Check Python syntax for both scripts:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run the full test suite:\n   ~/.pyenv/versions/3.11.*/bin/python -m pytest\
      \ tests/ -v\n\n3. Verify the new agent definitions exist:\n   test -f .claude/agents/ux-implementer.md\
      \ && echo \"ux-implementer.md exists\"\n   test -f .claude/agents/ux-designer.md\
      \ && echo \"ux-designer.md exists\"\n\n4. Verify ux-designer has Opus model:\n\
      \   grep -c \"model: opus\" .claude/agents/ux-designer.md\n\n5. Verify ux-implementer\
      \ has Sonnet model:\n   grep -c \"model: sonnet\" .claude/agents/ux-implementer.md\n\
      \n6. Verify suspension constants exist:\n   python3 -c \"\n   import importlib.util\n\
      \   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   assert hasattr(mod, 'UX_DESIGN_MAX_ROUNDS'), 'UX_DESIGN_MAX_ROUNDS not found'\n\
      \   assert hasattr(mod, 'SUSPENDED_DIR'), 'SUSPENDED_DIR not found'\n   assert\
      \ hasattr(mod, 'SUSPENSION_TIMEOUT_MINUTES'), 'SUSPENSION_TIMEOUT_MINUTES not\
      \ found'\n   assert callable(mod.create_suspension_marker), 'create_suspension_marker\
      \ not callable'\n   assert callable(mod.is_item_suspended), 'is_item_suspended\
      \ not callable'\n   print('All new constants and functions verified OK')\n \
      \  \"\n\n7. Run orchestrator dry-run to confirm no startup errors:\n   python3\
      \ scripts/plan-orchestrator.py --plan .claude/plans/sample-plan.yaml --dry-run\n\
      \n8. Run the fallback test command:\n   python3 -m pytest tests/ 2>/dev/null\
      \ || echo 'No test suite configured'\n\nIf any check fails, report the specific\
      \ failure with details.\n\nFiles: scripts/plan-orchestrator.py, scripts/auto-pipeline.py,\n\
      \  .claude/agents/ux-designer.md, .claude/agents/ux-implementer.md,\n  tests/test_plan_orchestrator.py,\
      \ plugin.json, RELEASE-NOTES.md\n"
