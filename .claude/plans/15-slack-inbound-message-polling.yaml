meta:
  name: Slack Inbound Message Polling
  description: 'Poll the Slack channel for new human messages at control-flow boundaries
    in the auto-pipeline and orchestrator. Classify each message and take action:
    create backlog items (feature/defect), answer questions, respond to control commands
    (stop/skip/status), or acknowledge informational messages. Extends the existing
    SlackNotifier class with inbound polling via conversations.history API. Uses synchronous
    polling at existing checkpoints - no background threads. Prefix-based message
    classification with extensible pattern table.'
  plan_doc: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md
  created: '2026-02-16'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
    - coder
    validators:
    - validator
    max_validation_attempts: 1
sections:
- id: phase-1
  name: Phase 1 - Config Template Update
  status: completed
  tasks:
  - id: '1.1'
    name: Add channels:history scope to config template
    agent: coder
    status: completed
    description: "Update the Slack config template to include the channels:history\
      \ permission needed for reading channel messages.\nReference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read .claude/slack.local.yaml.template.\n2. In the setup instructions\
      \ comment (line 8), change:\n   #   3. Add Bot Token Scopes (OAuth & Permissions):\
      \ chat:write, channels:read\n   to:\n   #   3. Add Bot Token Scopes (OAuth &\
      \ Permissions): chat:write, channels:read, channels:history\n\n3. Verify the\
      \ template is still valid YAML:\n   python3 -c \"\n   import yaml\n   with open('.claude/slack.local.yaml.template')\
      \ as f:\n       config = yaml.safe_load(f)\n   assert config['slack']['enabled']\
      \ is True\n   assert 'bot_token' in config['slack']\n   assert 'channels:history'\
      \ in open('.claude/slack.local.yaml.template').read()\n   print('Template validated\
      \ OK with channels:history scope')\n   \"\n\nFiles: .claude/slack.local.yaml.template"
    attempts: 1
    last_attempt: '2026-02-16T20:46:47.530526'
    model_used: sonnet
    completed_at: '2026-02-16T20:48:15.046047'
    result_message: Added channels:history scope to .claude/slack.local.yaml.template.
      Updated setup instructions comment to include the permission needed for conversations.history
      API. Template validated and committed.
- id: phase-2
  name: Phase 2 - Message Polling and Classification
  status: completed
  tasks:
  - id: '2.1'
    name: Add constants and poll_messages with last-read tracking
    agent: coder
    status: completed
    depends_on:
    - '1.1'
    description: "Add inbound message polling to SlackNotifier in scripts/plan-orchestrator.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the Slack constants section\
      \ (around line 72-82).\n2. After the existing SLACK_LEVEL_EMOJI dict, add two\
      \ new constants:\n   SLACK_LAST_READ_PATH = \".claude/slack-last-read.json\"\
      \n   SLACK_INBOUND_POLL_LIMIT = 20\n\n3. In the SlackNotifier class, add a new\
      \ method _load_last_read:\n   def _load_last_read(self) -> str:\n       \"\"\
      \"Load the last-read message timestamp from disk.\n       Returns '0' if no\
      \ prior state exists (will only process messages\n       from this session forward\
      \ by using current time on first poll).\n       \"\"\"\n       try:\n      \
      \     with open(SLACK_LAST_READ_PATH, \"r\") as f:\n               data = json.load(f)\n\
      \           return data.get(\"last_ts\", \"0\")\n       except (IOError, json.JSONDecodeError):\n\
      \           return \"0\"\n\n4. Add _save_last_read method:\n   def _save_last_read(self,\
      \ ts: str) -> None:\n       \"\"\"Persist the last-read timestamp to disk.\"\
      \"\"\n       try:\n           data = {\"channel_id\": self._channel_id, \"last_ts\"\
      : ts}\n           with open(SLACK_LAST_READ_PATH, \"w\") as f:\n           \
      \    json.dump(data, f)\n       except IOError as e:\n           print(f\"[SLACK]\
      \ Failed to save last-read state: {e}\")\n\n5. Add poll_messages method:\n \
      \  def poll_messages(self) -> list:\n       \"\"\"Fetch unread messages since\
      \ last poll from the Slack channel.\n       Uses conversations.history API with\
      \ oldest parameter.\n       Filters out bot messages. Updates last-read timestamp.\n\
      \       Returns empty list if disabled, no new messages, or on error.\n    \
      \   \"\"\"\n       if not self._enabled or not self._bot_token or not self._channel_id:\n\
      \           return []\n\n       last_ts = self._load_last_read()\n       # On\
      \ first run, use current time to avoid processing history\n       if last_ts\
      \ == \"0\":\n           import time as _time\n           current_ts = str(_time.time())\n\
      \           self._save_last_read(current_ts)\n           return []\n\n     \
      \  try:\n           params = urllib.parse.urlencode({\n               \"channel\"\
      : self._channel_id,\n               \"oldest\": last_ts,\n               \"\
      limit\": SLACK_INBOUND_POLL_LIMIT,\n               \"inclusive\": \"false\"\n\
      \           })\n           url = f\"https://slack.com/api/conversations.history?{params}\"\
      \n           req = urllib.request.Request(\n               url,\n          \
      \     headers={\"Authorization\": f\"Bearer {self._bot_token}\"}\n         \
      \  )\n           with urllib.request.urlopen(req, timeout=10) as resp:\n   \
      \            result = json.loads(resp.read())\n\n           if not result.get(\"\
      ok\", False):\n               print(f\"[SLACK] conversations.history error:\
      \ {result.get('error', 'unknown')}\")\n               return []\n\n        \
      \   messages = result.get(\"messages\", [])\n           if not messages:\n \
      \              return []\n\n           # Filter out bot messages (our own posts\
      \ and other bots)\n           human_messages = [\n               m for m in\
      \ messages\n               if not m.get(\"bot_id\") and m.get(\"subtype\") is\
      \ None\n           ]\n\n           # Update last-read to the newest message\
      \ timestamp\n           # messages are returned newest-first by the API\n  \
      \         newest_ts = messages[0].get(\"ts\", last_ts)\n           self._save_last_read(newest_ts)\n\
      \n           return human_messages\n\n       except Exception as e:\n      \
      \     print(f\"[SLACK] Failed to poll messages: {e}\")\n           return []\n\
      \n6. Add \"import urllib.parse\" near the top of the file with the other stdlib\n\
      \   imports (check if it is already imported; if not, add it after the\n   existing\
      \ urllib.request import).\n\n7. Verify syntax:\n   python3 -c \"import py_compile;\
      \ py_compile.compile('scripts/plan-orchestrator.py', doraise=True); print('syntax\
      \ OK')\"\n\n8. Verify new methods exist:\n   python3 -c \"\n   import importlib.util\n\
      \   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   notifier = mod.SlackNotifier('/nonexistent')\n   assert hasattr(notifier,\
      \ 'poll_messages'), 'Missing poll_messages'\n   assert hasattr(notifier, '_load_last_read'),\
      \ 'Missing _load_last_read'\n   assert hasattr(notifier, '_save_last_read'),\
      \ 'Missing _save_last_read'\n   assert hasattr(mod, 'SLACK_LAST_READ_PATH'),\
      \ 'Missing SLACK_LAST_READ_PATH'\n   assert hasattr(mod, 'SLACK_INBOUND_POLL_LIMIT'),\
      \ 'Missing SLACK_INBOUND_POLL_LIMIT'\n   print('poll_messages and last-read\
      \ tracking verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T20:48:17.416415'
    model_used: sonnet
    completed_at: '2026-02-16T20:51:06.896561'
    result_message: Added SLACK_LAST_READ_PATH and SLACK_INBOUND_POLL_LIMIT constants,
      and implemented poll_messages with _load_last_read and _save_last_read methods
      for tracking last-read timestamp
  - id: '2.2'
    name: Add classify_message method
    agent: coder
    status: completed
    depends_on:
    - '2.1'
    description: "Add message classification to SlackNotifier in scripts/plan-orchestrator.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class.\n\
      2. Add a classify_message method after poll_messages:\n   def classify_message(self,\
      \ text: str) -> tuple:\n       \"\"\"Classify a Slack message by its text content.\n\
      \n       Returns (classification, title, body) where:\n       - classification:\
      \ one of 'new_feature', 'new_defect', 'control_stop',\n         'control_skip',\
      \ 'info_request', 'question', 'acknowledgement'\n       - title: extracted title\
      \ (first line after prefix removal)\n       - body: remaining text (lines after\
      \ the first)\n       \"\"\"\n       if not text or not text.strip():\n     \
      \      return (\"acknowledgement\", \"\", \"\")\n\n       text = text.strip()\n\
      \       lower = text.lower()\n       lines = text.split(\"\\n\", 1)\n      \
      \ first_line = lines[0].strip()\n       body = lines[1].strip() if len(lines)\
      \ > 1 else \"\"\n\n       # Feature request\n       for prefix in (\"feature:\"\
      , \"enhancement:\"):\n           if lower.startswith(prefix):\n            \
      \   title = first_line[len(prefix):].strip()\n               return (\"new_feature\"\
      , title, body)\n\n       # Defect report\n       for prefix in (\"defect:\"\
      , \"bug:\"):\n           if lower.startswith(prefix):\n               title\
      \ = first_line[len(prefix):].strip()\n               return (\"new_defect\"\
      , title, body)\n\n       # Control commands\n       if lower.startswith(\"stop\"\
      ) or lower.startswith(\"pause\"):\n           return (\"control_stop\", first_line,\
      \ \"\")\n       if lower.startswith(\"skip\"):\n           return (\"control_skip\"\
      , first_line, \"\")\n\n       # Status request\n       if lower.startswith(\"\
      status\"):\n           return (\"info_request\", first_line, \"\")\n\n     \
      \  # Question detection\n       question_words = (\"what\", \"how\", \"where\"\
      , \"when\", \"why\", \"which\", \"can\", \"is\", \"are\", \"do\", \"does\",\
      \ \"will\", \"should\")\n       if text.rstrip().endswith(\"?\") or any(lower.startswith(w)\
      \ for w in question_words):\n           return (\"question\", first_line, body)\n\
      \n       return (\"acknowledgement\", first_line, body)\n\n3. Verify syntax:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n4. Quick smoke test:\n   python3 -c\
      \ \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   notifier = mod.SlackNotifier('/nonexistent')\n\
      \   assert hasattr(notifier, 'classify_message'), 'Missing classify_message'\n\
      \   cls, title, body = notifier.classify_message('feature: Add cache TTL')\n\
      \   assert cls == 'new_feature', f'Expected new_feature, got {cls}'\n   assert\
      \ title == 'Add cache TTL', f'Expected title, got {title}'\n   cls2, _, _ =\
      \ notifier.classify_message('stop')\n   assert cls2 == 'control_stop', f'Expected\
      \ control_stop, got {cls2}'\n   cls3, _, _ = notifier.classify_message('what\
      \ is the status?')\n   assert cls3 == 'question', f'Expected question, got {cls3}'\n\
      \   print('classify_message verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T20:51:09.286324'
    model_used: sonnet
    completed_at: '2026-02-16T20:53:09.936665'
    result_message: 'Added classify_message method to SlackNotifier class with support
      for 7 classification types: new_feature, new_defect, control_stop, control_skip,
      info_request, question, and acknowledgement'
  - id: '2.3'
    name: Add create_backlog_item method
    agent: coder
    status: completed
    depends_on:
    - '2.2'
    description: "Add backlog item creation from Slack messages to SlackNotifier.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class.\n\
      2. Add a create_backlog_item method:\n   def create_backlog_item(self, item_type:\
      \ str, title: str, body: str,\n                           user: str = \"\",\
      \ ts: str = \"\") -> str:\n       \"\"\"Create a backlog markdown file from\
      \ a Slack message.\n\n       Args:\n           item_type: 'feature' or 'defect'\n\
      \           title: Item title\n           body: Item description\n         \
      \  user: Slack user ID who sent the message\n           ts: Message timestamp\n\
      \n       Returns:\n           Created file path, or empty string on error\n\
      \       \"\"\"\n       if item_type == \"feature\":\n           backlog_dir\
      \ = \"docs/feature-backlog\"\n       elif item_type == \"defect\":\n       \
      \    backlog_dir = \"docs/defect-backlog\"\n       else:\n           return\
      \ \"\"\n\n       # Find next available number\n       try:\n           existing\
      \ = [f for f in os.listdir(backlog_dir)\n                       if f.endswith(\"\
      .md\") and f[0].isdigit()]\n           numbers = []\n           for f in existing:\n\
      \               parts = f.split(\"-\", 1)\n               if parts[0].isdigit():\n\
      \                   numbers.append(int(parts[0]))\n           next_num = max(numbers)\
      \ + 1 if numbers else 1\n       except (OSError, ValueError):\n           next_num\
      \ = 1\n\n       # Create slug from title\n       slug = title.lower().strip()\n\
      \       slug = slug.replace(\" \", \"-\")\n       # Remove non-alphanumeric\
      \ chars except hyphens\n       slug = \"\".join(c for c in slug if c.isalnum()\
      \ or c == \"-\")\n       slug = slug.strip(\"-\")\n       if not slug:\n   \
      \        slug = \"untitled\"\n\n       filename = f\"{next_num}-{slug}.md\"\n\
      \       filepath = os.path.join(backlog_dir, filename)\n\n       # Build markdown\
      \ content\n       source_line = \"Created from Slack message\"\n       if user:\n\
      \           source_line += f\" by {user}\"\n       if ts:\n           source_line\
      \ += f\" at {ts}\"\n       source_line += \".\"\n\n       content = (\n    \
      \       f\"# {title}\\n\\n\"\n           f\"## Status: Open\\n\\n\"\n      \
      \     f\"## Priority: Medium\\n\\n\"\n           f\"## Summary\\n\\n\"\n   \
      \        f\"{body if body else title}\\n\\n\"\n           f\"## Source\\n\\\
      n\"\n           f\"{source_line}\\n\"\n       )\n\n       try:\n           os.makedirs(backlog_dir,\
      \ exist_ok=True)\n           with open(filepath, \"w\") as f:\n            \
      \   f.write(content)\n           # Confirm in Slack\n           item_label =\
      \ \"feature\" if item_type == \"feature\" else \"defect\"\n           self.send_status(\n\
      \               f\"*Created {item_label} backlog item:* {filename}\",\n    \
      \           level=\"success\"\n           )\n           return filepath\n  \
      \     except IOError as e:\n           print(f\"[SLACK] Failed to create backlog\
      \ item: {e}\")\n           return \"\"\n\n3. Verify syntax:\n   python3 -c \"\
      import py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True);\
      \ print('syntax OK')\"\n\n4. Verify method exists:\n   python3 -c \"\n   import\
      \ importlib.util\n   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   notifier = mod.SlackNotifier('/nonexistent')\n   assert hasattr(notifier,\
      \ 'create_backlog_item'), 'Missing create_backlog_item'\n   print('create_backlog_item\
      \ method verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T20:53:12.251138'
    model_used: sonnet
    completed_at: '2026-02-16T20:55:28.996575'
    result_message: Added create_backlog_item method to SlackNotifier class - creates
      feature/defect markdown files from Slack messages with auto-numbering and confirmation
  - id: '2.4'
    name: Add handle_control_command and answer_question methods
    agent: coder
    status: completed
    depends_on:
    - '2.3'
    description: "Add control command handling and question answering to SlackNotifier.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class and\n\
      \   the STOP_SEMAPHORE_PATH constant (should be defined near the top).\n\n2.\
      \ Add handle_control_command method:\n   def handle_control_command(self, command:\
      \ str, classification: str) -> None:\n       \"\"\"Handle a control command\
      \ from Slack.\n\n       Args:\n           command: The original message text\n\
      \           classification: One of 'control_stop', 'control_skip', 'info_request'\n\
      \       \"\"\"\n       if classification == \"control_stop\":\n           #\
      \ Write stop semaphore to signal graceful stop\n           try:\n          \
      \     with open(STOP_SEMAPHORE_PATH, \"w\") as f:\n                   f.write(f\"\
      stop requested via Slack: {command}\\n\")\n               self.send_status(\n\
      \                   \"*Stop requested* via Slack. Pipeline will stop after current\
      \ task.\",\n                   level=\"warning\"\n               )\n       \
      \    except IOError as e:\n               print(f\"[SLACK] Failed to write stop\
      \ semaphore: {e}\")\n\n       elif classification == \"control_skip\":\n   \
      \        self.send_status(\n               \"*Skip requested* via Slack. (Note:\
      \ skip is not yet implemented \"\n               \"in the orchestrator. Use\
      \ 'stop' to halt the pipeline.)\",\n               level=\"warning\"\n     \
      \      )\n\n       elif classification == \"info_request\":\n           # Post\
      \ a basic status response\n           # Full pipeline state is not available\
      \ inside SlackNotifier,\n           # so we post what we can determine\n   \
      \        self.send_status(\n               \"*Pipeline Status*\\nState: running\\\
      n\"\n               \"_Use the terminal for detailed status._\",\n         \
      \      level=\"info\"\n           )\n\n3. Add answer_question method:\n   def\
      \ answer_question(self, question: str) -> None:\n       \"\"\"Respond to a question\
      \ from Slack.\n\n       For now, acknowledges the question and suggests using\
      \ the terminal\n       for detailed answers. A future enhancement could use\
      \ an LLM call.\n\n       Args:\n           question: The question text\n   \
      \    \"\"\"\n       self.send_status(\n           f\"*Question received:* {question}\\\
      n\"\n           \"_Detailed answers are not yet available via Slack. \"\n  \
      \         \"Check the terminal session for full pipeline context._\",\n    \
      \       level=\"info\"\n       )\n\n4. Verify syntax:\n   python3 -c \"import\
      \ py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True);\
      \ print('syntax OK')\"\n\n5. Verify methods exist:\n   python3 -c \"\n   import\
      \ importlib.util\n   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   notifier = mod.SlackNotifier('/nonexistent')\n   assert hasattr(notifier,\
      \ 'handle_control_command'), 'Missing handle_control_command'\n   assert hasattr(notifier,\
      \ 'answer_question'), 'Missing answer_question'\n   print('handle_control_command\
      \ and answer_question verified OK')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T20:55:31.356824'
    model_used: sonnet
    completed_at: '2026-02-16T20:57:50.567349'
    result_message: Added handle_control_command and answer_question methods to SlackNotifier.
      Control commands write stop semaphore or post status. Questions are acknowledged
      with guidance to use terminal.
  - id: '2.5'
    name: Add process_inbound orchestration method
    agent: coder
    status: completed
    depends_on:
    - '2.4'
    description: "Add the main process_inbound method that ties together polling,\
      \ classification, and dispatch in SlackNotifier.\nReference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the SlackNotifier class.\n\
      2. Add process_inbound method (should be the last public method):\n   def process_inbound(self)\
      \ -> None:\n       \"\"\"Poll for new Slack messages, classify, and act on each.\n\
      \n       This is the main entry point called at pipeline checkpoints.\n    \
      \   Catches all exceptions to never disrupt the pipeline.\n       No-op if Slack\
      \ is disabled.\n       \"\"\"\n       if not self._enabled:\n           return\n\
      \n       try:\n           messages = self.poll_messages()\n           for msg\
      \ in messages:\n               text = msg.get(\"text\", \"\").strip()\n    \
      \           if not text:\n                   continue\n\n               user\
      \ = msg.get(\"user\", \"unknown\")\n               ts = msg.get(\"ts\", \"\"\
      )\n\n               classification, title, body = self.classify_message(text)\n\
      \n               if classification == \"new_feature\":\n                   self.create_backlog_item(\"\
      feature\", title, body, user, ts)\n               elif classification == \"\
      new_defect\":\n                   self.create_backlog_item(\"defect\", title,\
      \ body, user, ts)\n               elif classification in (\"control_stop\",\
      \ \"control_skip\", \"info_request\"):\n                   self.handle_control_command(text,\
      \ classification)\n               elif classification == \"question\":\n   \
      \                self.answer_question(text)\n               elif classification\
      \ == \"acknowledgement\":\n                   # Log but don't spam Slack with\
      \ receipts\n                   print(f\"[SLACK] Acknowledged message from {user}:\
      \ {text[:80]}\")\n               else:\n                   print(f\"[SLACK]\
      \ Unhandled classification: {classification}\")\n\n       except Exception as\
      \ e:\n           # Never let inbound processing disrupt the pipeline\n     \
      \      print(f\"[SLACK] Error in process_inbound: {e}\")\n\n3. Verify syntax:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/plan-orchestrator.py',\
      \ doraise=True); print('syntax OK')\"\n\n4. Verify method exists and is callable\
      \ on disabled notifier:\n   python3 -c \"\n   import importlib.util\n   spec\
      \ = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   notifier = mod.SlackNotifier('/nonexistent')\n   assert hasattr(notifier,\
      \ 'process_inbound'), 'Missing process_inbound'\n   # Should be a no-op when\
      \ disabled\n   notifier.process_inbound()\n   print('process_inbound verified\
      \ OK (no-op when disabled)')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T20:57:53.013894'
    model_used: sonnet
    completed_at: '2026-02-16T21:00:09.956618'
    result_message: Added process_inbound orchestration method to SlackNotifier. Method
      polls messages, classifies them, and dispatches to appropriate handlers. No-op
      when disabled, exception-safe to prevent pipeline disruption.
- id: phase-3
  name: Phase 3 - Pipeline Integration
  status: completed
  tasks:
  - id: '3.1'
    name: Integrate process_inbound into auto-pipeline
    agent: coder
    status: completed
    depends_on:
    - '2.5'
    description: "Add slack.process_inbound() calls at checkpoints in auto-pipeline.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/auto-pipeline.py. Find the main_loop function (around\
      \ line 1524).\n2. Find the line \"items = scan_all_backlogs()\" (around line\
      \ 1597).\n   Add BEFORE that line:\n       # Poll for inbound Slack messages\
      \ at scan checkpoint\n       slack.process_inbound()\n\n3. Find the first process_item\
      \ call in the items loop (around line 1648):\n       success = process_item(item,\
      \ dry_run, session_tracker)\n   Add AFTER the \"if not success:\" block that\
      \ follows it (after line ~1651):\n       # Poll for inbound Slack messages after\
      \ processing each item\n       slack.process_inbound()\n\n4. Find the idle wait\
      \ block (around line 1615):\n       new_item_event.clear()\n       new_item_event.wait(timeout=SAFETY_SCAN_INTERVAL_SECONDS)\n\
      \   Add BEFORE the new_item_event.clear() line:\n       # Poll for inbound Slack\
      \ messages during idle wait\n       slack.process_inbound()\n\n5. Verify syntax:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); print('syntax OK')\"\n\n6. Verify process_inbound calls exist:\n\
      \   python3 -c \"\n   with open('scripts/auto-pipeline.py') as f:\n       content\
      \ = f.read()\n   count = content.count('slack.process_inbound()')\n   assert\
      \ count >= 3, f'Expected at least 3 process_inbound calls, found {count}'\n\
      \   print(f'Found {count} slack.process_inbound() calls in auto-pipeline.py')\n\
      \   \"\n\nFiles: scripts/auto-pipeline.py"
    attempts: 1
    last_attempt: '2026-02-16T21:00:12.429676'
    model_used: sonnet
    completed_at: '2026-02-16T21:02:09.371148'
    result_message: 'Added slack.process_inbound() calls at three checkpoints in auto-pipeline.py
      main_loop: before scan, after each item, and during idle wait'
  - id: '3.2'
    name: Integrate process_inbound into orchestrator
    agent: coder
    status: completed
    depends_on:
    - '2.5'
    description: "Add slack.process_inbound() calls at checkpoints in plan-orchestrator.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read scripts/plan-orchestrator.py. Find the main execution loop\n\
      \   (the \"while True:\" block starting around line 3007).\n\n2. After the stop\
      \ semaphore check (around line 3016, after the \"break\"\n   from check_stop_requested),\
      \ add before the circuit breaker check:\n       # Poll for inbound Slack messages\
      \ between tasks\n       slack.process_inbound()\n\n3. Find the validation results\
      \ section (around line 3445, where\n   \"continue  # Retry the task\" is). Add\
      \ BEFORE that continue:\n       # Poll for inbound Slack messages after validation\n\
      \       slack.process_inbound()\n\n4. Verify syntax:\n   python3 -c \"import\
      \ py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True);\
      \ print('syntax OK')\"\n\n5. Verify process_inbound calls exist in orchestrator:\n\
      \   python3 -c \"\n   with open('scripts/plan-orchestrator.py') as f:\n    \
      \   content = f.read()\n   count = content.count('slack.process_inbound()')\n\
      \   assert count >= 2, f'Expected at least 2 process_inbound calls in orchestrator,\
      \ found {count}'\n   print(f'Found {count} slack.process_inbound() calls in\
      \ plan-orchestrator.py')\n   \"\n\nFiles: scripts/plan-orchestrator.py"
    attempts: 1
    last_attempt: '2026-02-16T21:02:11.732250'
    model_used: sonnet
    completed_at: '2026-02-16T21:04:13.385493'
    result_message: 'Added slack.process_inbound() calls at two integration points
      in plan-orchestrator.py: after stop semaphore check and after validation failure.
      Verified syntax and confirmed both calls exist.'
- id: phase-4
  name: Phase 4 - Unit Tests
  status: in_progress
  tasks:
  - id: '4.1'
    name: Test poll_messages and last-read tracking
    agent: coder
    status: completed
    depends_on:
    - '3.2'
    description: "Add unit tests for poll_messages and last-read state management\
      \ to tests/test_slack_notifier.py.\nReference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read tests/test_slack_notifier.py to understand the current test\
      \ structure\n   and imports.\n\n2. Read scripts/plan-orchestrator.py to understand\
      \ poll_messages, _load_last_read,\n   _save_last_read implementations.\n\n3.\
      \ Add the following test cases at the end of the test file:\n\n   a. test_load_last_read_no_file:\n\
      \      Use tmp_path. Create a SlackNotifier with a valid config.\n      Monkey-patch\
      \ SLACK_LAST_READ_PATH to a nonexistent path in tmp_path.\n      Assert _load_last_read()\
      \ returns \"0\".\n\n   b. test_save_and_load_last_read:\n      Use tmp_path.\
      \ Create a SlackNotifier with a valid config.\n      Monkey-patch SLACK_LAST_READ_PATH\
      \ to a path in tmp_path.\n      Call _save_last_read(\"1234567890.123456\").\n\
      \      Assert _load_last_read() returns \"1234567890.123456\".\n      Assert\
      \ the file contains the channel_id.\n\n   c. test_poll_messages_disabled:\n\
      \      Create a disabled SlackNotifier.\n      Assert poll_messages() returns\
      \ [].\n\n   d. test_poll_messages_first_run_sets_timestamp:\n      Use tmp_path.\
      \ Create an enabled SlackNotifier.\n      Monkey-patch SLACK_LAST_READ_PATH\
      \ to tmp_path.\n      On first call, poll_messages should save current time\
      \ and return [].\n      Verify the last-read file was created.\n\n   e. test_poll_messages_filters_bots:\n\
      \      Create a mock response for conversations.history that contains:\n   \
      \   - A human message: {\"text\": \"hello\", \"user\": \"U123\", \"ts\": \"\
      1.1\"}\n      - A bot message: {\"text\": \"status update\", \"bot_id\": \"\
      B123\", \"ts\": \"1.2\"}\n      - A message with subtype: {\"text\": \"joined\"\
      , \"subtype\": \"channel_join\", \"ts\": \"1.3\"}\n      Monkey-patch urllib.request.urlopen\
      \ to return this mock.\n      Set up last-read state.\n      Assert poll_messages\
      \ returns only the human message.\n\n   f. test_poll_messages_updates_last_read:\n\
      \      Similar to above but verify _save_last_read is called with\n      the\
      \ newest message timestamp after polling.\n\n4. Add the new SLACK constants\
      \ to the existing test_slack_config_constants_exist\n   test (or add a new test):\n\
      \   assert mod.SLACK_LAST_READ_PATH == \".claude/slack-last-read.json\"\n  \
      \ assert mod.SLACK_INBOUND_POLL_LIMIT == 20\n\n5. Run tests:\n   python3 -m\
      \ pytest tests/test_slack_notifier.py -v\n   Fix any failures.\n\nFiles: tests/test_slack_notifier.py"
    attempts: 1
    last_attempt: '2026-02-16T21:04:15.780752'
    model_used: sonnet
    completed_at: '2026-02-16T21:06:41.610715'
    result_message: 'Added 6 unit tests for poll_messages and last-read tracking:
      load/save state, first-run behavior, bot filtering, and timestamp updates. Updated
      constants test. All 25 tests pass.'
  - id: '4.2'
    name: Test classify_message
    agent: coder
    status: pending
    depends_on:
    - '4.1'
    description: "Add unit tests for classify_message to tests/test_slack_notifier.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read tests/test_slack_notifier.py to see current state after 4.1.\n\
      2. Add the following test cases:\n\n   a. test_classify_feature_request:\n \
      \     Assert classify_message(\"feature: Add cache TTL\") returns\n      (\"\
      new_feature\", \"Add cache TTL\", \"\").\n\n   b. test_classify_feature_with_body:\n\
      \      Assert classify_message(\"feature: Cache TTL\\nNeeds configurable expiry\"\
      )\n      returns (\"new_feature\", \"Cache TTL\", \"Needs configurable expiry\"\
      ).\n\n   c. test_classify_enhancement:\n      Assert classify_message(\"enhancement:\
      \ Better logging\") returns\n      (\"new_feature\", \"Better logging\", \"\"\
      ).\n\n   d. test_classify_defect:\n      Assert classify_message(\"defect: Broken\
      \ import in auth\") returns\n      (\"new_defect\", \"Broken import in auth\"\
      , \"\").\n\n   e. test_classify_bug:\n      Assert classify_message(\"bug: NullPointerException\
      \ on startup\") returns\n      (\"new_defect\", \"NullPointerException on startup\"\
      , \"\").\n\n   f. test_classify_stop:\n      Assert classify_message(\"stop\"\
      ) returns (\"control_stop\", \"stop\", \"\").\n\n   g. test_classify_pause:\n\
      \      Assert classify_message(\"pause\") returns (\"control_stop\", \"pause\"\
      , \"\").\n\n   h. test_classify_skip:\n      Assert classify_message(\"skip\"\
      ) returns (\"control_skip\", \"skip\", \"\").\n\n   i. test_classify_status:\n\
      \      Assert classify_message(\"status\") returns (\"info_request\", \"status\"\
      , \"\").\n\n   j. test_classify_question_mark:\n      Assert classify_message(\"\
      how much budget is left?\") returns\n      (\"question\", ...).\n\n   k. test_classify_question_word:\n\
      \      Assert classify_message(\"what is in the backlog\") returns\n      (\"\
      question\", ...).\n\n   l. test_classify_acknowledgement:\n      Assert classify_message(\"\
      sounds good\") returns\n      (\"acknowledgement\", \"sounds good\", \"\").\n\
      \n   m. test_classify_empty:\n      Assert classify_message(\"\") returns (\"\
      acknowledgement\", \"\", \"\").\n\n   n. test_classify_case_insensitive:\n \
      \     Assert classify_message(\"FEATURE: Test\") returns (\"new_feature\", ...).\n\
      \      Assert classify_message(\"Bug: something\") returns (\"new_defect\",\
      \ ...).\n\n3. Run tests:\n   python3 -m pytest tests/test_slack_notifier.py\
      \ -v\n   Fix any failures.\n\nFiles: tests/test_slack_notifier.py"
  - id: '4.3'
    name: Test create_backlog_item and process_inbound
    agent: coder
    status: pending
    depends_on:
    - '4.2'
    description: "Add unit tests for create_backlog_item and process_inbound to tests/test_slack_notifier.py.\n\
      Reference: docs/plans/2026-02-16-15-slack-inbound-message-polling-design.md\n\
      Steps:\n1. Read tests/test_slack_notifier.py to see current state after 4.2.\n\
      \   Read scripts/plan-orchestrator.py to see create_backlog_item implementation.\n\
      \n2. Add the following test cases:\n\n   a. test_create_backlog_feature:\n \
      \     Use tmp_path. Create a feature-backlog dir inside tmp_path.\n      Create\
      \ an enabled SlackNotifier, monkey-patch _post_message to capture calls.\n \
      \     Monkey-patch the backlog dir path in the method or pass appropriate args.\n\
      \      Actually: since create_backlog_item uses hardcoded \"docs/feature-backlog\"\
      ,\n      we need to either:\n      - Use monkeypatch to change os.listdir behavior\
      \ and open to write to tmp_path\n      - Or create actual docs/feature-backlog\
      \ dir in a temp working dir\n      The simplest approach: use monkeypatch.chdir(tmp_path),\
      \ create the dirs\n      inside tmp_path, then call create_backlog_item.\n\n\
      \      Steps:\n      1. monkeypatch.chdir(tmp_path)\n      2. os.makedirs(\"\
      docs/feature-backlog\")\n      3. Call create_backlog_item(\"feature\", \"Cache\
      \ TTL\", \"Add configurable expiry\", \"U123\", \"1234.5678\")\n      4. Assert\
      \ a file was created in docs/feature-backlog/\n      5. Read the file. Assert\
      \ it contains \"# Cache TTL\" and \"## Status: Open\"\n      6. Assert the file\
      \ starts with \"1-\" (first item)\n\n   b. test_create_backlog_defect:\n   \
      \   Similar to above but for defect type. Verify file in docs/defect-backlog/.\n\
      \n   c. test_create_backlog_numbering:\n      Create tmp working dir. Add an\
      \ existing file \"15-existing.md\" in\n      docs/feature-backlog/. Call create_backlog_item\
      \ for a feature.\n      Assert the new file starts with \"16-\".\n\n   d. test_process_inbound_disabled:\n\
      \      Create disabled SlackNotifier. Call process_inbound().\n      Assert\
      \ no error raised (no-op).\n\n   e. test_process_inbound_dispatches_feature:\n\
      \      Create an enabled SlackNotifier.\n      Monkey-patch poll_messages to\
      \ return [{\"text\": \"feature: New feature\", \"user\": \"U1\", \"ts\": \"\
      1.0\"}].\n      Monkey-patch create_backlog_item to capture calls.\n      Call\
      \ process_inbound().\n      Assert create_backlog_item was called with (\"feature\"\
      , \"New feature\", ...).\n\n   f. test_process_inbound_dispatches_stop:\n  \
      \    Similar but with \"stop\" message. Verify handle_control_command called.\n\
      \n   g. test_process_inbound_error_resilience:\n      Monkey-patch poll_messages\
      \ to raise an Exception.\n      Call process_inbound(). Assert no exception\
      \ propagates.\n\n3. Run all tests:\n   python3 -m pytest tests/test_slack_notifier.py\
      \ -v\n   Fix any failures.\n\nFiles: tests/test_slack_notifier.py"
- id: phase-5
  name: Phase 5 - Verification
  status: pending
  tasks:
  - id: '5.1'
    name: Verify syntax, tests, and dry-run
    agent: code-reviewer
    status: pending
    depends_on:
    - '4.3'
    description: "Run verification checks to confirm the Slack inbound message polling\
      \ feature works correctly.\nSteps:\n1. Check Python syntax for both scripts:\n\
      \   python3 -c \"import py_compile; py_compile.compile('scripts/auto-pipeline.py',\
      \ doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)\"\
      \n\n2. Run all unit tests:\n   python3 -m pytest tests/ 2>/dev/null || echo\
      \ 'No test suite configured'\n\n3. Verify SlackNotifier class has all new methods:\n\
      \   python3 -c \"\n   import importlib.util\n   spec = importlib.util.spec_from_file_location('po',\
      \ 'scripts/plan-orchestrator.py')\n   mod = importlib.util.module_from_spec(spec)\n\
      \   spec.loader.exec_module(mod)\n   notifier = mod.SlackNotifier('/nonexistent')\n\
      \   assert not notifier.is_enabled()\n   for method in ['poll_messages', 'classify_message',\
      \ 'create_backlog_item',\n                  'handle_control_command', 'answer_question',\
      \ 'process_inbound']:\n       assert hasattr(notifier, method), f'Missing {method}'\n\
      \   print('SlackNotifier class verified: all new inbound methods present')\n\
      \   \"\n\n4. Verify new constants exist:\n   python3 -c \"\n   import importlib.util\n\
      \   spec = importlib.util.spec_from_file_location('po', 'scripts/plan-orchestrator.py')\n\
      \   mod = importlib.util.module_from_spec(spec)\n   spec.loader.exec_module(mod)\n\
      \   assert mod.SLACK_LAST_READ_PATH == '.claude/slack-last-read.json'\n   assert\
      \ mod.SLACK_INBOUND_POLL_LIMIT == 20\n   print('New constants verified')\n \
      \  \"\n\n5. Verify process_inbound calls in auto-pipeline:\n   python3 -c \"\
      \n   with open('scripts/auto-pipeline.py') as f:\n       content = f.read()\n\
      \   count = content.count('slack.process_inbound()')\n   assert count >= 3,\
      \ f'Expected at least 3 process_inbound calls, found {count}'\n   print(f'auto-pipeline.py:\
      \ {count} process_inbound calls')\n   \"\n\n6. Verify process_inbound calls\
      \ in orchestrator:\n   python3 -c \"\n   with open('scripts/plan-orchestrator.py')\
      \ as f:\n       content = f.read()\n   count = content.count('slack.process_inbound()')\n\
      \   assert count >= 2, f'Expected at least 2 process_inbound calls, found {count}'\n\
      \   print(f'plan-orchestrator.py: {count} process_inbound calls')\n   \"\n\n\
      7. Verify config template has channels:history scope:\n   python3 -c \"\n  \
      \ with open('.claude/slack.local.yaml.template') as f:\n       content = f.read()\n\
      \   assert 'channels:history' in content, 'Missing channels:history scope in\
      \ template'\n   print('Config template has channels:history scope')\n   \"\n\
      \n8. Run orchestrator dry-run to verify no startup errors:\n   python3 scripts/plan-orchestrator.py\
      \ --plan .claude/plans/sample-plan.yaml --dry-run\n\nIf any check fails, report\
      \ the failure with specific details.\nFiles: scripts/plan-orchestrator.py, scripts/auto-pipeline.py,\n\
      \       .claude/slack.local.yaml.template, tests/test_slack_notifier.py"
