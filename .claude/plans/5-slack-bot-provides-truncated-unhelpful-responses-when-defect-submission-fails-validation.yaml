meta:
  name: 'Defect Fix: Slack Bot Truncated/Unhelpful Responses on Defect Submission'
  description: >
    Fix three issues with Slack bot responses when defects are submitted:
    (1) Add message truncation to respect Slack Block Kit 3000-char limit,
    (2) Include backlog item ID and filename in confirmation messages,
    (3) Add classification rationale so users understand the decision.
    Also consolidate duplicate notifications between create_backlog_item()
    and _run_intake_analysis().
  plan_doc: docs/plans/2026-02-17-5-slack-bot-provides-truncated-unhelpful-responses-when-defect-submission-fails-validation-design.md
  created: '2026-02-17'
  max_attempts_default: 3
  validation:
    enabled: true
    run_after:
      - coder
    validators:
      - issue-verifier
    max_validation_attempts: 1

sections:
  - id: phase-1
    name: Phase 1 - Implementation
    status: pending
    tasks:
      - id: '1.1'
        name: Add _truncate_for_slack() helper and apply in _build_status_block()
        agent: coder
        status: pending
        description: >
          In scripts/plan-orchestrator.py, make the following changes:

          1. Add a new constant near the other Slack constants (around line 94):

             SLACK_BLOCK_TEXT_MAX_LENGTH = 2900

             This is 100 chars below Slack's 3000-char Block Kit section text limit,
             leaving room for the emoji prefix added by _build_status_block().

          2. Add a new static method after _build_status_block() (around line 2800):

             @staticmethod
             def _truncate_for_slack(text: str,
                                     max_length: int = SLACK_BLOCK_TEXT_MAX_LENGTH) -> str:
                 """Truncate text to fit Slack Block Kit section text limit.

                 If text exceeds max_length, truncates and appends an indicator
                 showing how many characters were omitted.

                 Args:
                     text: Message text to truncate
                     max_length: Maximum allowed length (default SLACK_BLOCK_TEXT_MAX_LENGTH)

                 Returns:
                     Text that fits within max_length
                 """
                 if len(text) <= max_length:
                     return text
                 omitted = len(text) - max_length + 40
                 return text[:max_length - 40] + f"\n_...({omitted} chars omitted)_"

          3. In _build_status_block() (around line 2794), apply truncation to the
             combined emoji + message string before inserting into the block:

             Change this line:
                 "text": {"type": "mrkdwn", "text": f"{emoji} {message}"}
             To:
                 full_text = self._truncate_for_slack(f"{emoji} {message}")
                 ...
                 "text": {"type": "mrkdwn", "text": full_text}

             Restructure the method body so full_text is computed first, then used
             in the return dict.

          After making changes, verify syntax:
            python3 -c "import py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

      - id: '1.2'
        name: Update create_backlog_item() to return metadata dict and remove its notification
        agent: coder
        depends_on:
          - '1.1'
        status: pending
        description: >
          In scripts/plan-orchestrator.py, modify create_backlog_item() (line 3211):

          1. Change the return type from str to dict. The method currently returns
             the filepath string on success or empty string on error. Change it to
             return a dict with keys: filepath, filename, item_number on success,
             or an empty dict on error.

             On error paths (line 3230 "return ''" and line 3287 "return ''"),
             change to: return {}

             On the success path (line 3285 "return filepath"), change to:
               return {"filepath": filepath, "filename": filename, "item_number": next_num}

          2. Remove the duplicate Slack notification from create_backlog_item().
             Delete lines 3280-3284 which send:
               self.send_status(
                   f"*Created {item_label} backlog item:* {filename}",
                   level="success"
               )
             The caller (_run_intake_analysis) will handle notifications instead.

          3. Update all callers of create_backlog_item() to handle the new dict return:

             In _run_intake_analysis() (lines 3614-3617 and 3647-3650), the return
             value is currently ignored. Capture it:
               item_info = self.create_backlog_item(...)

             In the exception handler (lines 3663-3666), same change:
               item_info = self.create_backlog_item(...)

          After making changes, verify syntax:
            python3 -c "import py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

      - id: '1.3'
        name: Add classification to intake prompt and parse response
        agent: coder
        depends_on:
          - '1.2'
        status: pending
        description: >
          In scripts/plan-orchestrator.py, make the following changes:

          1. Update INTAKE_ANALYSIS_PROMPT (line 120) to add a Classification field.
             Replace the entire prompt template with:

             INTAKE_ANALYSIS_PROMPT = """Analyze this {item_type} request using the 5 Whys method.

             Request: {text}

             Perform a 5 Whys analysis to uncover the root need behind this request.
             Then write a concise backlog item with a clear title and description.
             Also classify whether this is truly a {item_type} or should be categorized differently.

             Format your response exactly like this:

             Title: <one-line title for the backlog item>

             Classification: <defect|feature|question> - <one sentence explaining why>

             5 Whys:
             1. <why>
             2. <why>
             3. <why>
             4. <why>
             5. <why>

             Root Need: <the root need uncovered by the analysis>

             Description:
             <2-4 sentence description of the backlog item, incorporating the root need>
             Keep it concise and actionable."""

          2. Update _parse_intake_response() (line 3549) to extract the Classification field.

             Add to the result dict initialization (line 3561):
               "classification": ""

             Add parsing after the title extraction (around line 3567):
               class_match = re.search(r"^Classification:\s*(.+)$", text, re.MULTILINE)
               if class_match:
                   result["classification"] = class_match.group(1).strip()

          3. Update _run_intake_analysis() (around line 3630) to capture and use
             the classification field:

             After the existing line: root_need = parsed["root_need"]
             Add: classification = parsed["classification"]

          After making changes, verify syntax:
            python3 -c "import py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

      - id: '1.4'
        name: Consolidate intake notifications with item reference and classification
        agent: coder
        depends_on:
          - '1.2'
          - '1.3'
        status: pending
        description: >
          In scripts/plan-orchestrator.py, update _run_intake_analysis() to send
          comprehensive, consolidated Slack notifications.

          1. Update the successful analysis path (around line 3652-3656).
             Replace the existing notification code:

               notify_msg = f"*{intake.item_type.title()} created:* {title}"
               if root_need:
                   notify_msg += f"\n_Root need: {root_need}_"
               self.send_status(notify_msg, level="success", channel_id=intake.channel_id)

             With a version that includes item reference and classification:

               # Build comprehensive notification
               item_ref = ""
               if item_info:
                   item_ref = f" (#{item_info['item_number']} - `{item_info['filename']}`)"
               notify_msg = f"*{intake.item_type.title()} created{item_ref}:* {title}"
               if classification:
                   notify_msg += f"\n_Classification: {classification}_"
               if root_need:
                   notify_msg += f"\n_Root need: {root_need}_"
               self.send_status(notify_msg, level="success", channel_id=intake.channel_id)

          2. Update the empty LLM response fallback path (around line 3618-3622).
             After self.create_backlog_item(), capture the return:

               item_info = self.create_backlog_item(...)
               item_ref = ""
               if item_info:
                   item_ref = f" (#{item_info['item_number']} - `{item_info['filename']}`)"
               self.send_status(
                   f"*{intake.item_type.title()} received{item_ref}:* {fallback_title}\n"
                   "_(Analysis unavailable, created from raw text)_",
                   level="success", channel_id=intake.channel_id,
               )

          3. Update the exception handler fallback path (around line 3662-3671).
             Same pattern - capture return and include item reference:

               item_info = self.create_backlog_item(...)
               item_ref = ""
               if item_info:
                   item_ref = f" (#{item_info['item_number']} - `{item_info['filename']}`)"
               self.send_status(
                   f"*{intake.item_type.title()} received{item_ref}:* {fallback_title}\n"
                   f"_(Error during analysis: {e})_",
                   level="warning", channel_id=intake.channel_id,
               )

          After making changes, verify syntax:
            python3 -c "import py_compile; py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

  - id: phase-2
    name: Phase 2 - Unit Tests
    status: pending
    tasks:
      - id: '2.1'
        name: Add unit tests for _truncate_for_slack() and updated intake notification flow
        agent: coder
        depends_on:
          - '1.4'
        status: pending
        description: >
          Create or extend tests for the changes in scripts/plan-orchestrator.py.

          First check if tests/test_plan_orchestrator.py exists. If not, create it.
          Import the module using importlib:

            import importlib.util
            spec = importlib.util.spec_from_file_location("plan_orchestrator", "scripts/plan-orchestrator.py")
            mod = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(mod)
            SlackNotifier = mod.SlackNotifier
            SLACK_BLOCK_TEXT_MAX_LENGTH = mod.SLACK_BLOCK_TEXT_MAX_LENGTH

          Write these tests:

          1. test_truncate_for_slack_short_message:
             - Input: "Hello world" (well under limit)
             - Expected: unchanged output
             - Assert result == "Hello world"

          2. test_truncate_for_slack_exact_limit:
             - Input: "x" * SLACK_BLOCK_TEXT_MAX_LENGTH
             - Expected: unchanged (exactly at limit, not over)
             - Assert len(result) == SLACK_BLOCK_TEXT_MAX_LENGTH

          3. test_truncate_for_slack_over_limit:
             - Input: "x" * (SLACK_BLOCK_TEXT_MAX_LENGTH + 500)
             - Expected: truncated with omission indicator
             - Assert len(result) <= SLACK_BLOCK_TEXT_MAX_LENGTH
             - Assert "chars omitted" in result

          4. test_truncate_for_slack_custom_limit:
             - Input: "x" * 200, max_length=100
             - Expected: truncated to fit 100 chars
             - Assert len(result) <= 100
             - Assert "chars omitted" in result

          5. test_parse_intake_response_with_classification:
             - Call SlackNotifier._parse_intake_response() with a response that
               includes a Classification: line
             - Assert result["classification"] is extracted correctly

          6. test_parse_intake_response_without_classification:
             - Call _parse_intake_response() with a response missing Classification:
             - Assert result["classification"] == ""

          7. test_create_backlog_item_returns_dict:
             - This test verifies create_backlog_item returns a dict with the
               expected keys. Create a minimal SlackNotifier with _enabled=False
               and call create_backlog_item() for a defect with a test title.
             - Use a temporary directory or mock os.makedirs and open to avoid
               creating real files. Alternatively, if the test creates files,
               clean them up in a finally block.
             - Assert result has keys: filepath, filename, item_number
             - Assert result["item_number"] is an int

          After writing tests, run them:
            python3 -m pytest tests/test_plan_orchestrator.py -v

          Fix any failures immediately. If there are more than 3 failures,
          rewrite the failing tests based on the actual code behavior.

  - id: phase-3
    name: Phase 3 - Verification
    status: pending
    tasks:
      - id: '3.1'
        name: Verify syntax and run full test suite
        agent: code-reviewer
        depends_on:
          - '2.1'
        status: pending
        description: >
          Run the following verification steps:

          1. Compile-check both main scripts:
             python3 -c "import py_compile; py_compile.compile('scripts/auto-pipeline.py', doraise=True); py_compile.compile('scripts/plan-orchestrator.py', doraise=True)"

          2. Run the full test suite:
             python3 -m pytest tests/ 2>/dev/null || echo 'No test suite configured'

          3. Verify SLACK_BLOCK_TEXT_MAX_LENGTH constant exists:
             grep -n "SLACK_BLOCK_TEXT_MAX_LENGTH" scripts/plan-orchestrator.py
             Expected: at least 2 matches (definition + usage).

          4. Verify _truncate_for_slack method exists:
             grep -n "def _truncate_for_slack" scripts/plan-orchestrator.py
             Expected: exactly one match.

          5. Verify _build_status_block calls _truncate_for_slack:
             grep -A5 "def _build_status_block" scripts/plan-orchestrator.py
             Expected: _truncate_for_slack appears in the method body.

          6. Verify create_backlog_item returns dict (no more bare string returns):
             grep -n "return filepath" scripts/plan-orchestrator.py
             Expected: zero matches (old pattern removed).
             grep -n "item_number" scripts/plan-orchestrator.py
             Expected: matches in both create_backlog_item and _run_intake_analysis.

          7. Verify classification parsing exists:
             grep -n "classification" scripts/plan-orchestrator.py
             Expected: matches in _parse_intake_response, INTAKE_ANALYSIS_PROMPT,
             and _run_intake_analysis.

          8. Verify create_backlog_item no longer sends its own notification:
             grep -n "Created.*backlog item" scripts/plan-orchestrator.py
             Expected: zero matches (removed the duplicate notification).

          9. Verify intake notifications include item reference:
             grep -n "item_ref" scripts/plan-orchestrator.py
             Expected: multiple matches in _run_intake_analysis.

          Report findings as PASS/WARN/FAIL for each check.
